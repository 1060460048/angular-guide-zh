@ngdoc overview
@name 表单(Forms)
@description
翻译者:[@NigelYao](https://github.com/NigelYao)

Controls (`input`, `select`, `textarea`) are ways for a user to enter data.
A Form is a collection of controls for the purpose of grouping related controls together. 

控件 (`input`, `select`, `textarea`) 是用户输入数据的方式。一个表单就是多个控件的集合，用来组织相关的控件。

Form and controls provide validation services, so that the user can be notified of invalid input.
This provides a better user experience, because the user gets instant feedback on how to correct the error.
Keep in mind that while client-side validation plays an important role in providing good user experience, it can easily be circumvented and thus can not be trusted.
Server-side validation is still necessary for a secure application.

表单和控件提供验证服务，这样一来用户就能在输入信息有误的时候得到提示。
这提升了用户体验，因为我们在第一时间就会告知用户什么地方出错了、如何修正错误。
记住，尽管客户端（浏览器）验证在用户体验方面起了重要作用，但是，它很容易被绕过，因此是不能被系统信任的。
为了应用的安全，服务端的验证仍然是必须的。

# Simple form

# 简单的表单

The key directive in understanding two-way data-binding is {@link api/ng.directive:ngModel ngModel}.
The `ngModel` directive provides the two-way data-binding by synchronizing the model to the view, as well as view to the model.
In addition it provides an {@link api/ng.directive:ngModel.NgModelController API} for other directives to augment its behavior.

理解双向绑定的关键指令是{@link api/ng.directive:ngModel ngModel}。
指令`ngModel`通过同步数据模型到视图中，同样也同步视图到数据模型中的方式实现了双向绑定。
另外，它还提供了{@link api/ng.directive:ngModel.NgModelController API}来让其他指令扩展它的行为。

<doc:example>
<doc:source>
<div ng-controller="Controller">
  <form novalidate class="simple-form">
    Name: <input type="text" ng-model="user.name" /><br />
    E-mail: <input type="email" ng-model="user.email" /><br />
    Gender: <input type="radio" ng-model="user.gender" value="male" />male
    <input type="radio" ng-model="user.gender" value="female" />female<br />
    <button ng-click="reset()">RESET</button>
    <button ng-click="update(user)">SAVE</button>
  </form>
  <pre>form = {{user | json}}</pre>
  <pre>master = {{master | json}}</pre>
</div>

<script>
  function Controller($scope) {
    $scope.master = {};

    $scope.update = function(user) {
      $scope.master = angular.copy(user);
    };

    $scope.reset = function() {
      $scope.user = angular.copy($scope.master);
    };

    $scope.reset();
  }
  </script>
</doc:source>
</doc:example>


Note that `novalidate` is used to disable browser's native form validation.

注意 `novalidate` 是用来禁用浏览器中自带的验证功能的（译注：否则angular的验证机制可能没有机会执行）。



# Using CSS classes

# 使用 CSS 类

To allow styling of form as well as controls, `ngModel`  add these CSS classes:

- `ng-valid`
- `ng-invalid`
- `ng-pristine`
- `ng-dirty`

为了允许对表单和控件自定义样式， `ngModel` 增加了如下的CSS类：

- `ng-valid`
- `ng-invalid`
- `ng-pristine`
- `ng-dirty`

The following example uses the CSS to display validity of each form control.
In the example both `user.name` and `user.email` are required, but are rendered with red background only when they are dirty.
This ensures that the user is not distracted with an error until after interacting with the control, and failing to satisfy its validity.

接下来的例子使用了CSS来显示每一个表单控件的有效性。
在例子中，`user.name` 和 `user.email` 两者都是必填项，但是只有当它们成为脏数据(dirty)才会显示红色背景。
这保证了用户不会因为还没有与控件进行交互，又恰好不符合验证条件，而出现不恰当的错误提示。

<doc:example>
<doc:source>
<div ng-controller="Controller">
  <form novalidate class="css-form">
    Name:
      <input type="text" ng-model="user.name" required /><br />
    E-mail: <input type="email" ng-model="user.email" required /><br />
    Gender: <input type="radio" ng-model="user.gender" value="male" />male
    <input type="radio" ng-model="user.gender" value="female" />female<br />
    <button ng-click="reset()">RESET</button>
    <button ng-click="update(user)">SAVE</button>
  </form>
</div>

<style type="text/css">
  .css-form input.ng-invalid.ng-dirty {
    background-color: #FA787E;
  }

  .css-form input.ng-valid.ng-dirty {
    background-color: #78FA89;
  }
</style>

<script>
  function Controller($scope) {
    $scope.master = {};

    $scope.update = function(user) {
      $scope.master = angular.copy(user);
    };

    $scope.reset = function() {
      $scope.user = angular.copy($scope.master);
    };

    $scope.reset();
  }
  </script>
</doc:source>
</doc:example>


# Binding to form and control state

# 绑定到表单于控件的状态

A form is an instance of {@link api/ng.directive:form.FormController FormController}.
The form instance can optionally be published into the scope using the `name` attribute.

每个表单都是 {@link api/ng.directive:form.FormController FormController} 的实例。
这个表单实例会通过同名的属性装载到作用域(scope)中。表单的name值就是它在作用域(scope)实例中的属性名。

Similarly, an input control that has the {@link api/ng.directive:ngModel} directive holds an
instance of {@link api/ng.directive:ngModel.NgModelController NgModelController}.
Such a control instance can be published as a property of the form instance using the `name` attribute
on the input control.  The name attribute specifies the name of the property on the form instance.

类似的，每个拥有 {@link api/ng.directive:ngModel} 指令的输入控件，都是{@link api/ng.directive:ngModel.NgModelController NgModelController}的实例。
这个控件实例会通过同名的属性装载到表单实例中去。元素的name值就是它在表单实例中的属性名。

This implies that the internal state of both the form and the control is available for binding in
the view using the standard binding primitives.

这意味着，视图中只要使用基本的数据绑定形式可以访问到表单和控件的内部状态。

This allows us to extend the above example with these features:

- RESET button is enabled only if form has some changes
- SAVE button is enabled only if form has some changes and is valid
- custom error messages for `user.email` and `user.agree`

这让我们可以为上面的例子扩展出以下功能：

- RESET按钮 只在表单有改变的时候才可用
- SAVE按钮 只在表单有改变且数据有效的时候才可用
- 为 `user.email` 和 `user.agree` 自定义错误提示信息

<doc:example>
<doc:source>
<div ng-controller="Controller">
  <form name="form" class="css-form" novalidate>
    Name:
      <input type="text" ng-model="user.name" name="uName" required /><br />
    E-mail:
      <input type="email" ng-model="user.email" name="uEmail" required/><br />
    <div ng-show="form.uEmail.$dirty && form.uEmail.$invalid">Invalid:
      <span ng-show="form.uEmail.$error.required">Tell us your email.</span>
      <span ng-show="form.uEmail.$error.email">This is not a valid email.</span>
    </div>

    Gender: <input type="radio" ng-model="user.gender" value="male" />male
    <input type="radio" ng-model="user.gender" value="female" />female<br />

    <input type="checkbox" ng-model="user.agree" name="userAgree" required />
    I agree: <input ng-show="user.agree" type="text" ng-model="user.agreeSign"
              required /><br />
    <div ng-show="!user.agree || !user.agreeSign">Please agree and sign.</div>

    <button ng-click="reset()" ng-disabled="isUnchanged(user)">RESET</button>
    <button ng-click="update(user)"
            ng-disabled="form.$invalid || isUnchanged(user)">SAVE</button>
  </form>
</div>

<script>
  function Controller($scope) {
    $scope.master = {};

    $scope.update = function(user) {
      $scope.master = angular.copy(user);
    };

    $scope.reset = function() {
      $scope.user = angular.copy($scope.master);
    };

    $scope.isUnchanged = function(user) {
      return angular.equals(user, $scope.master);
    };

    $scope.reset();
  }
</script>
</doc:source>
</doc:example>



# Custom Validation

# 自定义验证

Angular provides basic implementation for most common html5 {@link api/ng.directive:input input}
types: ({@link api/ng.directive:input.text text}, {@link api/ng.directive:input.number number}, {@link api/ng.directive:input.url url}, {@link api/ng.directive:input.email email}, {@link api/ng.directive:input.radio radio}, {@link api/ng.directive:input.checkbox checkbox}), as well as some directives for validation (`required`, `pattern`, `minlength`, `maxlength`, `min`, `max`).

Angular提供了一些常用的html5输入控件的验证实现：({@link api/ng.directive:input.text text}, {@link api/ng.directive:input.number number}, {@link api/ng.directive:input.url url}, {@link api/ng.directive:input.email email}, {@link api/ng.directive:input.radio radio}, {@link api/ng.directive:input.checkbox checkbox}), 以及一些用于验证的指令 (`required`, `pattern`, `minlength`, `maxlength`, `min`, `max`).

Defining your own validator can be done by defining your own directive which adds a custom validation function to the `ngModel` {@link api/ng.directive:ngModel.NgModelController controller}.
To get a hold of the controller the directive specifies a dependency as shown in the example below.

你自己的验证器也可以定义一个指令，这个指令为 'ngModel'({@link api/ng.directive:ngModel.NgModelController NgModelController}) 添加了自定义验证方法。
我们通过指定一个依赖来获得对这个控制器的引用，从下面的例子中可以看出。

The validation can occur in two places:

  * **Model to View update** -
    Whenever the bound model changes, all functions in {@link api/ng.directive:ngModel.NgModelController#properties_$formatters NgModelController#$formatters} array are pipe-lined, so that each of these functions has an opportunity to format the value and change validity state of the form control through {@link api/ng.directive:ngModel.NgModelController#methods_$setValidity NgModelController#$setValidity}.

  * **View to Model update** -
    In a similar way, whenever a user interacts with a control it calls {@link api/ng.directive:ngModel.NgModelController#methods_$setViewValue NgModelController#$setViewValue}.
This in turn pipelines all functions in the {@link api/ng.directive:ngModel.NgModelController#properties_$parsers NgModelController#$parsers} array, so that each of these functions has an opportunity to convert the value and change validity state of the form control through {@link api/ng.directive:ngModel.NgModelController#methods_$setValidity NgModelController#$setValidity}.

我们的验证在两个地方触发：

  * **数据到视图的更新** -
    任何时候，受约束的模型改变时，所有在{@link api/ng.directive:ngModel.NgModelController#properties_$formatters NgModelController#$formatters}数组中的方法都会被链式调用，这样一来，所有的方法都有机会对值来进行格式化并改变表单和控件的有效性状态，通过{@link api/ng.directive:ngModel.NgModelController#methods_$setValidity NgModelController#$setValidity}来实现。

  * **View to Model update** -
    类似的，当用户与一个控件交互时，调用{@link api/ng.directive:ngModel.NgModelController#methods_$setViewValue NgModelController#$setViewValue}.
    这又反过来链式调用了所有在{@link api/ng.directive:ngModel.NgModelController#properties_$parsers NgModelController#$parsers}数组中的方法，这样一来，所有的方法都有机会对值进行转换并改变表单和控件的有效性状态，通过{@link api/ng.directive:ngModel.NgModelController#methods_$setValidity NgModelController#$setValidity}来实现。

In the following example we create two directives.

  * The first one is `integer` and it validates whether the input is a valid integer.
    For example `1.23` is an invalid value, since it contains a fraction.
    Note that we unshift the array instead of pushing.
    This is because we want to be first parser and consume the control string value, as we need to execute the validation function before a conversion to number occurs.

  * The second directive is a `smart-float`.
    It parses both `1.2` and `1,2` into a valid float number `1.2`.
    Note that we can't use input type `number` here as HTML5 browsers would not allow the user to type what it would consider an invalid number such as `1,2`.

下面的示例中我们创建了两个指令。

  * 第一个指令是 'integer' 整形数字，它验证了输入是否是一个合法的整形数字。
    例如，'1.23'是一个非法值，因为它包含小数部分。
    注意，我们并没有对数组进行压栈操作，而是把它插入到开头。
    这是因为我们希望这个指令能第一个解析和处理控件的值，而不希望在我们执行验证前，值已经被转换成了数字。
  * 第二个指令是 'smart-float' 智能浮点数。
    它能解析 '1.2' 和 '1,2' 转换成合法的浮点数 '1.2'.
    注意我们此时不能在HTML5的浏览器中使用 'number' 类型，因为在这种情况下，浏览器不会允许用户输入像 '1,2' 这种被认为是不合法的数字。

<doc:example module="form-example1">
<doc:source>
<div ng-controller="Controller">
  <form name="form" class="css-form" novalidate>
    <div>
      Size (integer 0 - 10):
      <input type="number" ng-model="size" name="size"
             min="0" max="10" integer />{{size}}<br />
      <span ng-show="form.size.$error.integer">This is not valid integer!</span>
      <span ng-show="form.size.$error.min || form.size.$error.max">
        The value must be in range 0 to 10!</span>
    </div>

    <div>
      Length (float):
      <input type="text" ng-model="length" name="length" smart-float />
      {{length}}<br />
      <span ng-show="form.length.$error.float">
        This is not a valid float number!</span>
    </div>
  </form>
</div>

<script>
  var app = angular.module('form-example1', []);

  var INTEGER_REGEXP = /^\-?\d+$/;
  app.directive('integer', function() {
    return {
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        ctrl.$parsers.unshift(function(viewValue) {
          if (INTEGER_REGEXP.test(viewValue)) {
            // it is valid
            ctrl.$setValidity('integer', true);
            return viewValue;
          } else {
            // it is invalid, return undefined (no model update)
            ctrl.$setValidity('integer', false);
            return undefined;
          }
        });
      }
    };
  });

  var FLOAT_REGEXP = /^\-?\d+((\.|\,)\d+)?$/;
  app.directive('smartFloat', function() {
    return {
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        ctrl.$parsers.unshift(function(viewValue) {
          if (FLOAT_REGEXP.test(viewValue)) {
            ctrl.$setValidity('float', true);
            return parseFloat(viewValue.replace(',', '.'));
          } else {
            ctrl.$setValidity('float', false);
            return undefined;
          }
        });
      }
    };
  });
</script>
</doc:source>
</doc:example>


# Implementing custom form controls (using `ngModel`)
Angular implements all of the basic HTML form controls ({@link api/ng.directive:input input}, {@link api/ng.directive:select select}, {@link api/ng.directive:textarea textarea}), which should be sufficient for most cases.
However, if you need more flexibility, you can write your own form control as a directive.

# 实现自定义form控件(使用 'ngModel')
Angular实现了所有基本的HTML表单控件(({@link api/ng.directive:input input}, {@link api/ng.directive:select select}, {@link api/ng.directive:textarea textarea}),在绝大多数情况下能够很高效。
然而，如果你需要更多的灵活性，你可以使用指令来实现你的自定义表单控件。

In order for custom control to work with `ngModel` and to achieve two-way data-binding it needs to:

  - implement `$render` method, which is responsible for rendering the data after it passed the {@link   api/ng.directive:ngModel.NgModelController#properties_$formatters NgModelController#$formatters},
  - call `$setViewValue` method, whenever the user interacts with the control and model needs to be updated. This is usually done inside a DOM Event listener.

为了让自定义控件能够与'ngModel'协同工作，达到双向绑定的效果，它需要：

  - 实现 '$render' 方法，它负责在数据传递给所有{@link   api/ng.directive:ngModel.NgModelController#properties_$formatters NgModelController#$formatters}方法之后渲染数据。
  - 调用 '$setViewValue' 方法，在任何用户与控件交互后，模型需要更新的时候。这通常在一个DOM事件监听器里完成。

查看 {@link guide/directive $compileProvider.directive} 获得更多的信息。

The following example shows how to add two-way data-binding to contentEditable elements.

接下来的例子展示了如何为一个可编辑元素添加双向绑定。

<doc:example module="form-example2">
<doc:source>
<script>
  angular.module('form-example2', []).directive('contenteditable', function() {
    return {
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        // view -> model
        elm.on('blur', function() {
          scope.$apply(function() {
            ctrl.$setViewValue(elm.html());
          });
        });

        // model -> view
        ctrl.$render = function() {
          elm.html(ctrl.$viewValue);
        };

        // load init value from DOM
        ctrl.$setViewValue(elm.html());
      }
    };
  });
</script>

<div contentEditable="true" ng-model="content" title="Click to edit">Some</div>
<pre>model = {{content}}</pre>

<style type="text/css">
  div[contentEditable] {
    cursor: pointer;
    background-color: #D0D0D0;
  }
</style>
</doc:source>
</doc:example>
