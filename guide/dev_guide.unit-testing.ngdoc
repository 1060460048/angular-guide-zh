@ngdoc overview
@name Developer Guide: Unit Testing
@name 开发人员指南：单元测试
@description

JavaScript is a dynamically typed language which comes with great power of expression, but it also
comes with almost no help from the compiler. For this reason we feel very strongly that any code
written in JavaScript needs to come with a strong set of tests. We have built many features into
Angular which makes testing your Angular applications easy. So there is no excuse for not testing.

JavaScript是一个动态类型的语言，具有强大的表达能力，但同时，你几乎没法从编译器获得任何帮助。
因此，我们深切体会到：任何JavaScript程序都需要伴随着一组强大的测试。
我们在angular中引入了很多特性来让你更轻松的测试应用程序。
所以，想不写测试？不，没有任何借口！

# It is all about NOT mixing concerns

# 一切的关键是：不要把任务不同的揉成一团

Unit testing as the name implies is about testing individual units of code. Unit tests try to
answer questions such as "Did I think about the logic correctly?" or "Does the sort function order the list
in the right order?"

单元测试，顾名思义就是用于测试代码中不可分割的单元。单元测试试图回答下列问题：“我所认为的逻辑正确吗？”或者“我的sort函数是否按照正确的顺序排序了这个列表？”

In order to answer such a question it is very important that we can isolate the unit of code under test.
That is because when we are testing the sort function we don't want to be forced into creating
related pieces such as the DOM elements, or making any XHR calls in getting the data to sort.

为了回答上述问题，最重要的事情就是：我们要能把这个单元的代码隔离到一个独立的test模块中。
这是因为我们测试sort函数的时候，绝不会希望也被迫创建相关的部分 —— 比如DOM元素，或者先发起一个XHR调用来获取完数据才能测试sort函数。

While this may seem obvious it can be very difficult to call an individual function on a
typical project. The reason is that the developers often mix concerns resulting in a
piece of code which does everything. It makes an XHR request, it sorts the response data and then it
manipulates the DOM.

虽然这看起来无所谓，但在一个典型的项目中，想要调用一个独立函数确实是非常困难的。
原因在于，开发人员经常会把不同的任务揉成一团，导致一部分代码中往往会做很多很多事：发起XHR请求，对返回的数据进行排序，然后更新到DOM。

With Angular we try to make it easy for you to do the right thing, and so we
provide dependency injection for your XHR (which you can mock out) and we created abstractions which
allow you to sort your model without having to resort to manipulating the DOM. So that in the end,
it is easy to write a sort function which sorts some data, so that your test can create a data set,
apply the function, and assert that the resulting model is in the correct order. The test does not
have to wait for the XHR response to arrive, create the right kind of test DOM, nor assert that your
function has mutated the DOM in the right way.

在Angular中，我们尝试进行简化，来确保你总能“做正确的事”，所以，我们：
提供了依赖注入（DI），来让你自由使用XHR（这样你就能mock它了）；
我们创建了抽象层，让你可以排序你的模型(Model)，而不用去管DOM。
最终的结果就是：很容易写出这样一个对一些数据进行排序的sort函数，你的测试程序可以创建一组数据、调用sort函数，然后验证这些数据是否按照正确的顺序排列着。
这个测试不用等XHR返回结果，不用想方设法创建正确类型的测试用DOM，也不用验证DOM节点是否根据正确的顺序发生了变化。

## With great power comes great responsibility

## 能力越大，责任越大

Angular is written with testability in mind, but it still requires that you do the right thing.
We tried to make the right thing easy, but Angular is not magic. If you don't follow these guidelines
you may very well end up with an untestable application.

写Angular的核心思想之一就是“可测试性”，但是它仍然需要你按照正确的方式使用它。
你当然希望轻而易举的把事情做对，但Angular不是魔术。如果你不遵循下列指导原则，你仍然很可能得到一个不可测试的程序。

## Dependency Injection

## 依赖注入

There are several ways in which you can get a hold of a dependency. You can:
1. Create it using the `new` operator.
2. Look for it in a well-known place, also known as a global singleton.
3. Ask a registry (also known as service registry) for it. (But how do you get a hold of
the registry? Most likely by looking it up in a well known place. See #2.)
4. Expect it to be handed to you.

你可以有很多种方式保存所依赖的对象。比如：
1. 通过`new`运算符创建一个。
2. 在一个众所周知的地方找一个现成的，比如全局性的单例(singleton)对象。
3. 从一个注册表(registry)（比如服务注册表）中找一个现成的。（但是你如何找到一个注册表的引用呢？通常要从一个众所周知的地方寻找。参见#2。）
4. 期望它被某些人直接交到你手里。

Out of the four options in the list above, only the last one is testable. Let's look at why:

在这四种方案中，只有最后一个是可测试的。让我们分析一下这是为什么：

### Using the `new` operator

### 使用`new`运算符

While there is nothing wrong with the `new` operator fundamentally, a problem arises when calling `new`
on a constructor. This permanently binds the call site to the type. For example, lets say that we try to
instantiate an `XHR` that will retrieve data from the server.

本质上，使用`new`运算符没有任何错误，问题出现在从构造函数中调用`new`运算符的时候。
这种情况下，调用者被永久性的和它要`new`的这个类型打包在一起。比如，我们看看为了从服务器获得数据而对XHR进行实例化，会导致什么后果。

<pre>
function MyClass() {
  this.doWork = function() {
    var xhr = new XHR();
    xhr.open(method, url, true);
    xhr.onreadystatechange = function() {...}
    xhr.send();
  }
}
</pre>

A problem surfaces in tests when we would like to instantiate a `MockXHR` that would
allow us to return fake data and simulate network failures. By calling `new XHR()` we are
permanently bound to the actual XHR and there is no  way to replace it. Yes, we could monkey
patch, but that is a bad idea for many reasons which are outside the scope of this document.

在测试时，问题表现在：当我们想要实例化一个`MockXHR` —— 我们需要它来返回模拟数据，并且模拟网络异常。
如果我们调用`new XHR()`来获得实例，我们就永久性的和实际的XHR（而不是Mock的！）绑定在一起，并且没有任何办法替换它。
固然，我们可以使用猴子补丁（译注：monkey patch —— 见下面例子），但这绝对是个坏注意，理由很多，不过本文档中不展开论述。

Here's an example of how the class above becomes hard to test when resorting to monkey patching:
下面是一个例子，可以看出为何即使借助于猴子补丁仍然不是个好办法。
<pre>
var oldXHR = XHR;
XHR = function MockXHR() {};
var myClass = new MyClass();
myClass.doWork();
// assert that MockXHR got called with the right arguments
// 确保MockXHR按照正确的参数进行了调用
XHR = oldXHR; // if you forget this bad things will happen
XHR = oldXHR; // 如果你忘了写这句，就糟糕了
</pre>


### Global look-up:
### 全局查找：

Another way to approach the problem is to look for the service in a well-known location.

另一个方法是从一个众所周知的地方查找此服务。

<pre>
function MyClass() {
  this.doWork = function() {
    global.xhr({
      method:'...',
      url:'...',
      complete:function(response){ ... }
    })
  }
}
</pre>

While no new dependency instance is created, it is fundamentally the same as `new` in
that no  way exists to intercept the call to `global.xhr` for testing purposes, other then
through monkey patching. The basic issue for testing is that a global variable needs to be mutated in
order to replace it with call to a mock method. For further explanation of why this is bad see: {@link
http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/ Brittle Global
State & Singletons}

虽然这次没有直接创建新的依赖对象，问题仍然和`new`方案一样的：测试方仍然无法拦截对`global.xhr`的调用 —— 就算通过猴子补丁。
对测试来说，根本问题在于全局变量应该允许被测试方修改，以便能替换它，并且调用一个mock函数。
关于“这种方式为什么不好”的详细论述请参见：
{@link http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/ Brittle Global State & Singletons}

The class above is hard to test since we have to change the global state:
上面这个类之所以难于测试，原因就在于我们不得不修改全局状态：
<pre>
var oldXHR = global.xhr;
global.xhr = function mockXHR() {};
var myClass = new MyClass();
myClass.doWork();
// assert that mockXHR got called with the right arguments
// 确保mockXHR使用正确的参数调用了
global.xhr = oldXHR; // if you forget this bad things will happen
global.xhr = oldXHR; // 如果你忘了写这句，就糟糕了
</pre>


### Service Registry:
### 服务注册表

It may seem that this can be solved by having a registry of all the services and then
having the tests replace the services as needed.

粗看起来似乎有一个好办法解决这个问题：创建一个注册表，它保存着所有服务，那么测试方就可以替换这些服务了。

<pre>
function MyClass() {
  var serviceRegistry = ????;
  this.doWork = function() {
    var xhr = serviceRegistry.get('xhr');
    xhr({
      method:'...',
      url:'...',
      complete:function(response){ ... }
    })
}
</pre>

However, where does the serviceRegistry come from? If it is:
* `new`-ed up, the test has no chance to reset the services for testing.
*  a global look-up then the service returned is global as well (but resetting is easier, since
only one global variable exists to be reset).

问题在于，serviceRegistry从哪里来呢？如果：
* `new`出来的，那么测试方没有机会重定义这些服务以供测试。
* 全局查找，所返回的服务也是全局的（但是重定义比较容易，因为需要重定义的只有一个全局变量）

The class above is hard to test since we have to change the global state:
上面的这个类仍然难于测试，因为我们还是不得不修改全局状态：
<pre>
var oldServiceLocator = global.serviceLocator;
global.serviceLocator.set('xhr', function mockXHR() {});
var myClass = new MyClass();
myClass.doWork();
// assert that mockXHR got called with the right arguments
// 确保mockXHR被使用正确的参数调用
global.serviceLocator = oldServiceLocator; // if you forget this bad things will happen
global.serviceLocator = oldServiceLocator; // 如果你忘了写这句，就糟糕了
</pre>


### Passing in Dependencies:
### 传入依赖对象
Last, the dependency can be passed in.
最后，可以被动接收所依赖对象。

<pre>
function MyClass(xhr) {
  this.doWork = function() {
    xhr({
      method:'...',
      url:'...',
      complete:function(response){ ... }
    })
}
</pre>

This is the preferred method since the code makes no assumptions about the origin of `xhr` and cares
instead about whoever created the class  responsible for passing it in. Since the creator of the
class should be different code than the user of the class, it separates the responsibility of
creation from the logic. This is dependency-injection is in a nutshell.

这是首选方案！因为这段代码让我们不用对`xhr`从哪里来作出任何假设，而只要知道谁负责创建这个类并且传给我们就够了。
因为类的创建者和类的使用者一般不是同一个段代码，这里把创建类的职责从逻辑里面分离出去。这就是依赖注入的简易原理。

The class above is testable, since in the test we can write:
上面这个类是可测试的，在测试代码中我们可以这样写：
<pre>
function xhrMock(args) {...}
var myClass = new MyClass(xhrMock);
myClass.doWork();
// assert that xhrMock got called with the right arguments
// 确保xhrMock使用正确的参数调用
</pre>

Notice that no global variables were harmed in the writing of this test.
注意，这个测试中我们不用写任何全局变量。

Angular comes with {@link di dependency injection} built-in, making the right thing
easy to do, but you still need to do it if you wish to take advantage of the testability story.

Angular内建了{@link di 依赖注入}机制，让你可以很容易的“做正确的事”，但是如果你希望在可测试性方面更进一步，你还需要了解更多。 

## Controllers
## 控制器(Controller)
What makes each application unique is its logic, and the logic is what we would like to test. If the logic
for your application contains DOM manipulation, it will be hard to test. See the example
below:

让应用程序与众不同的地方在于它的“逻辑”，而“逻辑”正是我们想要测试的对象。
如果你的应用逻辑中包含了DOM操作，它就很难被测试了。参见下面的例子：

<pre>
function PasswordCtrl() {
  // get references to DOM elements
  // 获得DOM元素的引用
  var msg = $('.ex1 span');
  var input = $('.ex1 input');
  var strength;

  this.grade = function() {
    msg.removeClass(strength);
    var pwd = input.val();
    password.text(pwd);
    if (pwd.length > 8) {
      strength = 'strong';
    } else if (pwd.length > 3) {
      strength = 'medium';
    } else {
      strength = 'weak';
    }
    msg
     .addClass(strength)
     .text(strength);
  }
}
</pre>

The code above is problematic from a testability point of view since it requires your test to have the right kind
of DOM present when the code executes. The test would look like this:

上述代码在可测试性方面的问题在于，它需要你的测试代码在执行被测代码时提供正确类型的DOM。测试代码看起来是这样的：

<pre>
var input = $('<input type="text"/>');
var span = $('<span>');
$('body').html('<div class="ex1">')
  .find('div')
    .append(input)
    .append(span);
var pc = new PasswordCtrl();
input.val('abc');
pc.grade();
expect(span.text()).toEqual('weak');
$('body').html('');
</pre>

In angular the controllers are strictly separated from the DOM manipulation logic and this results in
a much easier testability story as the following example shows:

angular中，控制器被严格的与DOM操作相隔离。结果就是更轻易的提供可测试性，如下所示：

<pre>
function PasswordCtrl($scope) {
  $scope.password = '';
  $scope.grade = function() {
    var size = $scope.password.length;
    if (size > 8) {
      $scope.strength = 'strong';
    } else if (size > 3) {
      $scope.strength = 'medium';
    } else {
      $scope.strength = 'weak';
    }
  };
}
</pre>

and the test is straight forward:
测试代码也立即变得整洁了：

<pre>
var $scope = {};
var pc = $controller('PasswordCtrl', { $scope: $scope });
$scope.password = 'abc';
$scope.grade();
expect($scope.strength).toEqual('weak');
</pre>

Notice that the test is not only much shorter, it is also easier to follow what is happening. We say
that such a test tells a story, rather then asserting random bits which don't seem to be related.

注意，测试代码不仅仅是变短了，也能更简明的看出发生了什么。我们看到这段代码“描述了一个故事”，而不只是一组看起来互不相关的“点”。

## Filters
## 过滤器(Filter)
{@link api/ng.$filterProvider Filters} are functions which transform the data into a user readable
format. They are important because they remove the formatting responsibility from the application
logic, further simplifying the application logic.

{@link api/ng.$filterProvider Filters}是一个函数，用来把数据转换成用户可读的格式。
他们的重要性在于可把数据格式化方面的职责从应用逻辑中移除，从而简化了应用逻辑。
 
<pre>
myModule.filter('length', function() {
  return function(text){
    return (''+(text||'')).length;
  }
});

var length = $filter('length');
expect(length(null)).toEqual(0);
expect(length('abc')).toEqual(3);
</pre>

## Directives
## 指令(Directive)
Directives in angular are responsible for encapsulating complex functionality within custom HTML tags,
attributes, classes or comments. Unit tests are very important for directives because the components
you create with directives may be used throughout your application and in many different contexts.

Angular中的指令，用于通过自定义HTML标记(Tag)、属性(Attribute)、类(Class)或注释(Comment)的形式封装复杂的功能。
对于指令来说，单元测试是非常重要的，因为你创建的指令有可能被用于你的整个应用程序中，甚至被用在很多不同的环境中。

### Simple HTML Element Directive
### 简单HTML型元素指令

Let's start with an angular app with no dependencies.

我们先使用无依赖的形式启动一个angular应用。

<pre>
var app = angular.module('myApp', []);
</pre>

Now we can add a directive to our app.

然后在我们的应用中添加一个指令。

<pre>
app.directive('aGreatEye', function () {
    return {
        restrict: 'E',
        replace:  true,
        template: '<h1>lidless, wreathed in flame, {{1 + 1}} times</h1>'
    };
});
</pre>

This directive is used as a tag `<a-great-eye></a-great-eye>`. It replaces the entire tag with the
template `<h1>lidless, wreathed in flame, {{1 + 1}} times</h1>`. Now we are going to write a jasmine unit test to
verify this functionality. Note that the expression `{{1 + 1}}` times will also be evaluated in the rendered content.

这个这个指令作为标记(tag)时的用法是`<a-great-eye></a-great-eye>`。
这个标记会被模板`<h1>lidless, wreathed in flame, {{1 + 1}} times</h1>`代替。
另外，这里的`{{1 + 1}}`表达式在渲染内容时也将被计算。
接下来，我们将写一个jasmine（一种单元测试框架）单元测试，来验证这个功能。

<pre>
describe('Unit testing great quotes', function() {
describe('单元测试（大块）', function() {
    var $compile;
    var $rootScope;

    // Load the myApp module, which contains the directive
    // 加载myApp模块，它包含着指令
    beforeEach(module('myApp'));

    // Store references to $rootScope and $compile
    // so they are available to all tests in this describe block

    // 保存$rootScope和$compile的引用，以便它们能被这里的所有测试使用
    beforeEach(inject(function(_$compile_, _$rootScope_){
      // The injector unwraps the underscores (_) from around the parameter names when matching
      // 注射器匹配的时候会去掉参数名两端的下划线再匹配
      $compile = _$compile_;
      $rootScope = _$rootScope_;
    }));
    
    it('Replaces the element with the appropriate content', function() {
    it('用适当的内容替换元素', function() {
        // Compile a piece of HTML containing the directive
        // 编译一块包含指令的HTML
        var element = $compile("<a-great-eye></a-great-eye>")($rootScope);
        // fire all the watches, so the scope expression {{1 + 1}} will be evaluated
	// 触发所有的watch，以便在作用域中计算表达式{{1 + 1}}
        $rootScope.$digest();
        // Check that the compiled element contains the templated content
	// 检查编译后的元素中包含了模板中的内容
        expect(element.html()).toContain("lidless, wreathed in flame, 2 times");
    });
});
</pre>

We inject the $compile service and $rootScope before each jasmine test. The $compile service is used
to render the aGreatEye directive. After rendering the directive we ensure that the directive has
replaced the content and "lidless, wreathed in flame, 2 times" is present.

我们在每个jasmine测试中注入了$compile服务和$rootScope对象。
$compile服务用于渲染aGreatEye指令。
渲染这个指令后我们确保指令已经把内容替换成了 "lidless, wreathed in flame, 2 times" 

## Sample project
## 范例工程
See the {@link https://github.com/angular/angular-seed angular-seed} project for an example.

范例工程参见 {@link https://github.com/angular/angular-seed Angular种子工程}。
