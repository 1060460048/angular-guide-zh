@ngdoc overview
@name Developer Guide: Modules
@description

Translated by [@GrahamLe](https://github.com/grahamle)

# 何为模块？

大多数应用程序都有个 `main` 函数来初始化、连接以及启动整个应用。ng 中虽然没有 `main` 函数，它用模块来指定应用需要如何启动。这种策略有如下几种优势：

  * 整个过程是声明式的，更容易理解
  * 在单元测试中，没有必要加载所有模块，这样有利于单元测试的代码书写
  * 在场景测试中，额外的模块可以被加载进来进而重写一些配置，这样有助于应用的端到端的测试
  * 第三方代码可以很容易被打包作为可重用的模块
  * 模块可以以任何或是并行的顺序被加载（得益于模块执行的延迟性）

# 模块ABC

你会说，别废话一箩筐了，说个 Hello World 的模块示例吧，让它跑起来才是王道呀。

可以，在此之前，有几件重要的事情必须记住：

  * {@link api/angular.Module Module} API
  * 在 `<html ng-app="myApp">` ，注意对于 `myApp` 模块的引用，这是用模块的方法启动应用的触发点

<doc:example module='myApp'>
  <doc:source>
    <script>
      // 声明一个模块
      var myAppModule = angular.module('myApp', []);

      // 模块配置
      // 在这个例子中，我们创建一个过滤器
      myAppModule.filter('greet', function() {
       return function(name) {
          return 'Hello, ' + name + '!';
        };
      });

    </script>
    <div>
      {{ 'World' | greet }}
    </div>
  </doc:source>
</doc:example>



# 推荐配置

上面的例子太过简单了，对于大型应用显然不适用。对于大型app，我们推荐将应用像如下分为多个模块：

  * 服务模块
  * 指令模块
  * 过滤器模块
  * 一个应用级的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码

这样划分模块的原因主要是在你的测试中，经常需要忽略难以测试的初始化的代码，而且这样测试时可以单个加载模块进行相关的测试。

上述模块划分仅仅是一种建议性的方案，你可以根据自己app的需要去调整。下面的代码显示了上面所述的模块划分：

<doc:example module='xmpl'>
  <doc:source>
    <script>
      angular.module('xmpl.service', []).
        value('greeter', {
          salutation: 'Hello',
          localize: function(localization) {
            this.salutation = localization.salutation;
          },
          greet: function(name) {
            return this.salutation + ' ' + name + '!';
          }
        }).
        value('user', {
          load: function(name) {
            this.name = name;
          }
        });

      angular.module('xmpl.directive', []);

      angular.module('xmpl.filter', []);

      angular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']).
        run(function(greeter, user) {
          // 这相当于 main 函数
          greeter.localize({
            salutation: 'Bonjour'
          });
          user.load('World');
        })


      // 应用所需的一个控制器
      var XmplController = function($scope, greeter, user) {
        $scope.greeting = greeter.greet(user.name);
      }
    </script>
    <div ng-controller="XmplController">
      {{ greeting }}!
    </div>
  </doc:source>
 </doc:example>



# 模块加载及依赖

模块是配置代码块和运行代码块的集合，在启动阶段被执行。最简单的模块中包含下面两种代码块：

  1. **配置代码块** - 在 `provider` 注册和配置阶段执行（注：provider 是 ng 服务的一种）。只有 `provider` 和 `constant` 可以被注入配置代码块。这是为了防止服务在完全配置好之前被意外地初始化。
  2. **执行代码块** - 在 `injector` 被创建后执行，被用来启动整个应用。只有服务的实例对象以及 `constant` 可以被注入到执行代码块。这是为了防止在应用执行期间系统的更进一步的配置。

*译者注*：代码中的注释就不翻译了，应该是能看懂的。

<pre>
angular.module('myModule', []).
  config(function(injectables) { // provider-injector
    // This is an example of config block.
    // You can have as many of these as you want.
    // You can only inject Providers (not instances)
    // into the config blocks.
  }).
  run(function(injectables) { // instance-injector
    // This is an example of a run block.
    // You can have as many of these as you want.
    // You can only inject instances (not Providers)
    // into the run blocks
  });
</pre>

## 配置代码块

有一些快捷方法可供模块调用，效果等同于配置代码块，比如：

<pre>
angular.module('myModule', []).
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// 等同于

angular.module('myModule', []).
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { return 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });
</pre>

配置代码库被应用的顺序是根据它们被注册的顺序而定的。唯一的例外是 `constant` 的定义，它是被放在所有的配置代码块的最前面。

## 执行代码块

执行代码块是 ng 中最接近 `main` 函数的一个东西。执行代码块是应用启动需要运行的代码。它在所有的服务被配置好以及 `injector` 被创建好之后执行。通常，执行代码块包含的代码都很难进行单元测试，正因为如此，它通常被丢在单独的一个模块中，这样好让我们可以在单元测试时忽略它。

## 模块依赖

模块声明时可以列出它所需要依赖的别的模块。依赖一个模块意味着被依赖的模块需要在其本身被加载之前加载完毕。更具体些，假设模块A依赖于模块B，那么模块A的配置代码块的执行，发生在模块B的配置代码块之后；模块A的执行代码块亦同理，发生在模块B的执行代码块之后被执行。每个模块只能被加载一次，纵使有多个别的模块依赖于它。

## 异步加载

Modules are a way of managing $injector configuration, and have nothing to do with loading of
scripts into a VM. There are existing projects which deal with script loading, which may be used
with Angular. Because modules do nothing at load time they can be loaded into the VM in any order
and thus script loaders can take advantage of this property and parallelize the loading process.

## Creation versus Retrieval

Beware that using `angular.module('myModule', [])` will create the module `myModule` and overwrite any
existing module named `myModule`. Use `angular.module('myModule')` to retrieve an existing module.

<pre>
  var myModule = angular.module('myModule', []);
  
  // add some directives and services
  myModule.service('myService', ...);
  myModule.directive('myDirective', ...);

  // overwrites both myService and myDirective by creating a new module
  var myModule = angular.module('myModule', []);

  // throws an error because myOtherModule has yet to be defined
  var myModule = angular.module('myOtherModule');
</pre>

# 单元测试

In its simplest form a unit test is a way of instantiating a subset of the application in test and
then applying a stimulus to it. It is important to realize that each module can only be loaded
once per injector. Typically an app has only one injector. But in tests, each test has its own
injector, which means that the modules are loaded multiple times per VM. Properly structured
modules can help with unit testing, as in this example:

In all of these examples we are going to assume this module definition:
<pre>
  angular.module('greetMod', []).

    factory('alert', function($window) {
      return function(text) {
        $window.alert(text);
      }
    }).

    value('salutation', 'Hello').

    factory('greet', function(alert, salutation) {
      return function(name) {
        alert(salutation + ' ' + name + '!');
      }
    });
</pre>

Let's write some tests:
<pre>
describe('myApp', function() {
  // load the relevant application modules then load a special
  // test module which overrides the $window with a mock version,
  // so that calling window.alert() will not block the test
  // runner with a real alert box. This is an example of overriding
  // configuration information in tests.
  beforeEach(module('greetMod', function($provide) {
    $provide.value('$window', {
      alert: jasmine.createSpy('alert')
    });
  }));

  // The inject() will create the injector and inject the greet and
  // $window into the tests. The test need not concern itself with
  // wiring of the application, only with testing it.
  it('should alert on $window', inject(function(greet, $window) {
    greet('World');
    expect($window.alert).toHaveBeenCalledWith('Hello World!');
  }));

  // this is another way of overriding configuration in the
  // tests using an inline module and inject methods.
  it('should alert using the alert service', function() {
    var alertSpy = jasmine.createSpy('alert');
    module(function($provide) {
      $provide.value('alert', alertSpy);
    });
    inject(function(greet) {
      greet('World');
      expect(alertSpy).toHaveBeenCalledWith('Hello World!');
    });
  });
});
</pre>
