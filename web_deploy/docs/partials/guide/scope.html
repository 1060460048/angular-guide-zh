<a href="http://github.com/angular/angular.js/edit/master/docs/content/guide/scope.ngdoc" class="improve-docs btn btn-primary"><i class="icon-edit"> </i> Improve this doc</a><h1><code ng:non-bindable=""></code>
<div><span class="hint"></span>
</div>
</h1>
<div><div class="developer-guide-page developer-guide-scopes-page"><p>Translated by <a href="https://github.com/grahamle">@GrahamLe</a></p>
<h3 id="何为scopes">何为Scopes</h3>
<p><a href="api/ng.$rootScope.Scope"><code>scope</code></a> 
- 是一个存储应用数据模型的对象
- 为 <a href="guide/expression">expressions</a> 提供了一个执行上下文
- Scopes 的层级结构对应于 DOM 树结构
- Scopes 可以监听 <a href="guide/expression">expressions</a> 的变化并传播事件</p>
<h3 id="scopes有什么">Scopes有什么</h3>
<ul>
<li><p>Scopes 提供了 (<a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch</code></a>) 方法监听数据模型的变化</p>
</li>
<li><p>Scopes 提供了 (<a href="api/ng.$rootScope.Scope#methods_$apply"><code>$apply</code></a>) 方法把不是由 ng 触发的数据模型的改变引入 ng 的控制范围内（如控制器，服务，及 ng 事件处理器等）</p>
</li>
<li><p>Scopes 提供了基于原型式继承其父 scope 属性的机制，就算是嵌套于独立的应用组件中的 scopes 也是可以访问共享的数据模型（这个涉及到指令间嵌套时 scope 的几种模式）</p>
</li>
<li><p>Scopes 提供了 <a href="guide/expression">expressions</a> 的执行环境，比如像 <code>{{username}}</code> 这个表达式，必须得是在一个拥有属性这个属性的 scope 中执行才会有意义，也就是说，scope 中可能会像这样 <code>scope.username</code> 或是 <code>$scope.username</code>，至于有没有 $ 符号，看你是在哪里调用 scope 了</p>
</li>
</ul>
<h3 id="scope作为数据模型使用">Scope作为数据模型使用</h3>
<p>Scope 是应用（注：一般指web应用）的控制器和视图之间的粘结剂。在 ng 中，最直观的表现是：在自定义指令中，处在模版的 <a href="guide/compiler">linking</a> 阶段时， <a href="api/ng.$compileProvider#methods_directive"><code>directives</code></a> （指令）会设置一个 <a href="api/ng.$rootScope.Scope#methods_$watch"><code><code>$watch</code></code></a> 函数监听着 scope 中的各表达式（注：这个过程是隐性的）。这个 <code>$watch</code> 允许指令在 scope 中的属性变化时收到通知，进而指令能够根据这个改变来对DOM进行重新渲染，以便更新已改变的属性值（注：属性值就是scope对象中的属性，也就是数据模型）。</p>
<p>其实，不止上面所说的指令拥有指向 scope 的引用，控制器中也有（注：可以理解为控制器与指令均能引用到与它们相对应的DOM结构所处的 scope）。但是控制器与指令是相互分离的，而且它们与视图之间也是分离的，这样的分离，或者说耦合度低，可以大大提高对应用进行测试的这一块工作的效率。</p>
<p>注：其实可以很简单地理解为有以下两个链条关系：</p>
<ul>
<li>控制器 --&gt; scope --&gt; 视图（DOM）</li>
<li>指令 --&gt; scope --&gt; 视图（DOM）</li>
</ul>
<p>让我们来看下面一个例子，可以说明 scope 作为视图与控制器的黏合剂：</p>
<h3 id="source">Source</h3>
<div source-edit="" source-edit-deps="angular.js script.js" source-edit-html="index.html-94" source-edit-css="" source-edit-js="script.js-93" source-edit-json="" source-edit-unit="" source-edit-scenario=""></div>
<div class="tabbable"><div class="tab-pane" title="index.html">
<pre class="prettyprint linenums" ng-set-text="index.html-94" ng-html-wrap=" angular.js script.js"></pre>
<script type="text/ng-template" id="index.html-94">
    <div ng-controller="MyController">
      Your name:
        <input type="text" ng-model="username">
        <button ng-click='sayHello()'>greet</button>
      <hr>
      {{greeting}}
    </div>
  </script>
</div>
<div class="tab-pane" title="script.js">
<pre class="prettyprint linenums" ng-set-text="script.js-93"></pre>
<script type="text/ng-template" id="script.js-93">
    function MyController($scope) {
      $scope.username = 'World';

      $scope.sayHello = function() {
        $scope.greeting = 'Hello ' + $scope.username + '!';
      };
    }
  </script>
</div>
</div><h3 id="demo">Demo</h3>
<div class="well doc-example-live animate-container" ng-embed-app="" ng-set-html="index.html-94" ng-eval-javascript="script.js-93"></div>
<p>在上面这个例子中，我们有：</p>
<ul>
<li>控制器：<code>MyController</code>，它引用了 <code>$scope</code> 并在其上注册了两个属性和一个方法</li>
<li>$scope 对象：持有上面例子所需的数据模型，包括 <code>username</code> 属性、<code>greeting</code>属性（注：这是在<code>sayHello()</code>方法被调用时注册的）和 <code>sayHello()</code> 方法</li>
<li>视图：拥有一个输入框、一个按钮以及一个利用双向绑定来显示数据的内容块</li>
</ul>
<p>那么具体整个示例有这样两个流程，<strong>从控制器发起的角度</strong>来看就是：</p>
<ol>
<li>控制器往 scope 中写属性：<ul>
<li>给 scope 中的 <code>username</code> 赋值，然后 scope 通知视图中的 <code>input</code> 数据变化了，<code>input</code> 因为通过 <code>ng-model</code> 实现了双向绑定可以知道 <code>username</code> 的变化，进而在视图中渲染出改变的值，这里是 <code>World</code></li>
</ul>
</li>
<li>控制器往 scope 中写方法<ul>
<li>给 scope 中的 <code>sayHello()</code> 方法赋值，该方法接受视图中的 <code>button</code> 调用，因为 <code>button</code> 通过 <code>ng-click</code> 绑定了该方法，当用户点击按钮时，<code>sayHello()</code> 被调用，这个方法读取 scope 中的 <code>username</code> 属性，加上前缀字符串 <code>Hello</code>，然后赋值给在 scope 中新创建的 <code>greeting</code> 属性</li>
</ul>
</li>
</ol>
<p>整个示例的过程如果<strong>从视图的角度看</strong>，那主要是以下三个部分：</p>
<ol>
<li><p><code>input</code> 中的渲染逻辑：展示了通过 <code>ng-model</code> 进行的 scope 和 视图中某表单元素的双向绑定</p>
<ul>
<li>根据 <code>ng-model</code> 中的 <code>username</code> 去 scope 中取，如果已经有赋值，那么用这个默认值填充当前的输入框</li>
<li>接受用户输入，并且将用户输入的字符串传给 <code>username</code>，这时候 scope 中的该属性值实时对应用户输入的值</li>
</ul>
</li>
<li><p><code>button</code> 中的逻辑</p>
<ul>
<li>接受用户单击，调用 scope 中的 <code>sayHello()</code> 方法</li>
</ul>
</li>
<li><p><code>{{greeting}}</code> 的渲染逻辑</p>
<ul>
<li>在用户未单击按钮时，不显示内容</li>
<li><em>取值阶段</em>：在用户单击后，这个表达式会去scope中取 <code>greeting</code> 属性，而这个 scope 和控制器是同一个的（这个例子中），这时候，该 scope 下 <code>greeting</code> 属性已经有了，这时候这个属性就被取回来了</li>
<li><em>计算阶段</em>：在当前 scope 下去计算 <code>greeting</code> <a href="guide/expression">expression</a> ，然后渲染视图，显示 <code>Hello World</code></li>
</ul>
</li>
</ol>
<p>经过以上的两种角度分析示例过程，我们可以知道：**scope 对象以及其属性是视图渲染的唯一数据来源。</p>
<p>从测试的角度来看，视图与控制器分离的需求在于它允许测试人员可以单独对应用的操作逻辑进行测试，而不必考虑页面的渲染细节。</p>
<pre class="prettyprint linenums">
  it('should say hello', function() {
    var scopeMock = {};
    var cntl = new MyController(scopeMock);

    // Assert that username is pre-filled
    expect(scopeMock.username).toEqual('World');

    // Assert that we read new username and greet
    scopeMock.username = 'angular';
    scopeMock.sayHello();
    expect(scopeMock.greeting).toEqual('Hello angular!');
  });
</pre>
<h3 id="scope分层结构">Scope分层结构</h3>
<p>如上所说，scope 的结构对应于DOM结构，那么最顶层，和DOM树有根节点一样，每个 ng 应用有且仅有一个 <a href="api/ng.$rootScope"><code>root scope</code></a>，当然啦，子级 scope 就和DOM树的子节点一样，可以有多个的。</p>
<p>应用可以拥有多个 scope ，比如 <a href="guide/directive">directives</a> 会创建子级 scope （至于指令创建的 scope 是有多种类型的，详情参加指令相关文档）。一般情况下，当新的 scope 被创建时，它是以嵌入在父级 scope 的子级的形式被创建的，这样就形成了与其所关联的DOM树相对应的一个 scope 的树结构。（译者注：scope 的层级继承是基于原型链的继承，所以在下面的例子中会看到，读属性时会一直往上溯源，直到有未知）</p>
<p>scope 的分层的一个简单例子是，假设现在HTML视图中有一个表达式 <code>{{name}}</code> ，正如上面解释过，ng 需要经历取值和计算两个阶段才能最终在视图渲染结果。那么这个取值的阶段，其实就是根据 scope 的这个层级结构（或树状结构）来进行的。</p>
<ul>
<li>首先，ng 在该表达式当前所在的DOM节点所对应的 scope 中去找有没有 <code>name</code> 这个属性</li>
<li>如果有，ng 返回取值，计算渲染；如果在当前 scope 中没有找到，那么 ng 继续往上一层的父级 scope 中去找 <code>name</code> 属性，直到找到为止，最后实在没有，那就到达 <code>$rootScope</code> 了</li>
</ul>
<p>上面一个简单的例子展示了在 scope 分层结构中找属性，是基于原型继承的模式。接下来这个demo用一个图具体展示了 scope 的层级结构，让你可以有更直观的了解。</p>
<h3 id="source">Source</h3>
<div source-edit="" source-edit-deps="angular.js script.js" source-edit-html="index.html-95" source-edit-css="style.css-97" source-edit-js="script.js-96" source-edit-json="" source-edit-unit="" source-edit-scenario=""></div>
<div class="tabbable"><div class="tab-pane" title="index.html">
<pre class="prettyprint linenums" ng-set-text="index.html-95" ng-html-wrap=" angular.js script.js"></pre>
<script type="text/ng-template" id="index.html-95">
  <div class="show-scope-demo">
    <div ng-controller="GreetCtrl">
      Hello {{name}}!
    </div>
    <div ng-controller="ListCtrl">
      <ol>
        <li ng-repeat="name in names">{{name}} from {{department}}</li>
      </ol>
    </div>
  </div>
  </script>
</div>
<div class="tab-pane" title="style.css">
<pre class="prettyprint linenums" ng-set-text="style.css-97"></pre>
<style type="text/css" id="style.css-97">
    .show-scope-demo.ng-scope,
    .show-scope-demo .ng-scope  {
      border: 1px solid red;
      margin: 3px;
    }
  </style>
</div>
<div class="tab-pane" title="script.js">
<pre class="prettyprint linenums" ng-set-text="script.js-96"></pre>
<script type="text/ng-template" id="script.js-96">
    function GreetCtrl($scope, $rootScope) {
      $scope.name = 'World';
      $rootScope.department = 'Angular';
    }

    function ListCtrl($scope) {
      $scope.names = ['Igor', 'Misko', 'Vojta'];
    }
  </script>
</div>
</div><h3 id="demo">Demo</h3>
<div class="well doc-example-live animate-container" ng-embed-app="" ng-set-html="index.html-95" ng-eval-javascript="script.js-96"></div>
<p><img class="center" src="img/guide/concepts-scope.png"></p>
<p>看到上面的框中，注意，ng 会自动为每个拥有 scope 的DOM节点加上 <code>ng-scope</code> 类。上图中，拥有红色边框样式的节点，就意味着该节点拥有了自己的 scope ，无论它是通过什么方式创建的（<em>译者注：上面可以看到有通过控制器创建的新的 scope ，也有通过指令如 <code>ng-repeat</code> 创建的</em>）。上例中，<code>ng-repeat</code> 创建的子级 scope 是极其必要的，因为每个 <code>&lt;li&gt;</code> 中想要渲染输出的 <code>{{name}}</code> 显然是不同的值，那就需要为它们提供不同的 scope 。同样的，ng 在渲染 <code>{{department}}</code> 表达式时，先在当前和 <code>&lt;li&gt;</code> 相对应的 scope 去找有没有这个属性，如果没有，接着往上找，在这个例子中，直到找到 <code>$rootScope</code> 下时，才找到 <code>department</code> 属性，然后将其取回，计算，渲染输出。</p>
<h3 id="从dom中抓取scopes">从DOM中抓取Scopes</h3>
<p>Scope 对象是与指令或控制器等 ng 元素所在的DOM节点相关联的，也就是说，其实DOM节点上是可以抓取到 scope 这个对象的（当然，为了调试偶尔会用，一般不用）。
而对于 <code>$rootScope</code> 在哪里抓呢？它藏在 <code>ng-app</code> 指令所在的那个DOM节点之中，请看更多关于 <a href="api/ng.directive:ngApp"><code><code>ng-app</code></code></a> 指令。通常，<code>ng-app</code> 放在 <code>&lt;html&gt;</code> 标签中, 当然，如果你的应用中只是视图的某一部分想要用 ng 控制，那你可以把它放在想要控制的元素的最外层。</p>
<p>那来看看如何在调试的时候抓取 scope 吧： </p>
<ol>
<li><p>右键选去你想审查的元素，调出debugger，通常F12即可，这样你选中的元素会高亮显示（<em>译者注：感觉文档如果都看到这的人了，会需要这句提示么？原文档这是在卖萌么</em>）</p>
</li>
<li><p>此时，调试器（debugger）允许你用变量 <code>$0</code> 来获取当前选取的元素</p>
</li>
<li><p>在console中执行 <code>angular.element($0).scope()</code> 或直接输入 $scope 即可看到你想要查询的当前DOM元素节点绑定的 scope 了</p>
</li>
</ol>
<h3 id="基于scope的事件传播">基于Scope的事件传播</h3>
<p>Scope 可以像DOM节点一样，进行事件的传播。主要是有两个方法：</p>
<ul>
<li><a href="api/ng.$rootScope.Scope#methods_$broadcast"><code>broadcasted</code></a> ：从父级 scope 广播至子级 scope</li>
<li><a href="api/ng.$rootScope.Scope#methods_$emit"><code>emitted</code></a> ：从子级 scope 往上发射到父级 scope </li>
</ul>
<p>让我们来看个例子：</p>
<h3 id="source">Source</h3>
<div source-edit="" source-edit-deps="angular.js script.js" source-edit-html="index.html-99" source-edit-css="" source-edit-js="script.js-98" source-edit-json="" source-edit-unit="" source-edit-scenario=""></div>
<div class="tabbable"><div class="tab-pane" title="index.html">
<pre class="prettyprint linenums" ng-set-text="index.html-99" ng-html-wrap=" angular.js script.js"></pre>
<script type="text/ng-template" id="index.html-99">
    <div ng-controller="EventController">
      Root scope <tt>MyEvent</tt> count: {{count}}
      <ul>
        <li ng-repeat="i in [1]" ng-controller="EventController">
          <button ng-click="$emit('MyEvent')">$emit('MyEvent')</button>
          <button ng-click="$broadcast('MyEvent')">$broadcast('MyEvent')</button>
          <br>
          Middle scope <tt>MyEvent</tt> count: {{count}}
          <ul>
            <li ng-repeat="item in [1, 2]" ng-controller="EventController">
              Leaf scope <tt>MyEvent</tt> count: {{count}}
            </li>
          </ul>
        </li>
      </ul>
    </div>
  </script>
</div>
<div class="tab-pane" title="script.js">
<pre class="prettyprint linenums" ng-set-text="script.js-98"></pre>
<script type="text/ng-template" id="script.js-98">
    function EventController($scope) {
      $scope.count = 0;
      $scope.$on('MyEvent', function() {
        $scope.count++;
      });
    }
  </script>
</div>
</div><h3 id="demo">Demo</h3>
<div class="well doc-example-live animate-container" ng-embed-app="" ng-set-html="index.html-99" ng-eval-javascript="script.js-98"></div>
<p>译者注：上面例子很简单，有几个需要注意的是：</p>
<ul>
<li><code>$emit</code> 和 <code>$broadcast</code> 是直接被写在 html 模版中的，而不是写在控制器的 js 代码中，因为这两个方法是直接在 $scope 中就有的，</li>
<li>同一个控制器 <code>EventController</code> 被用在了三个不同的DOM节点中（<em>这是为了省事，通常不这样写的</em>）</li>
<li>上面的事件无非就是点击两个按钮，分别出发广播/冒泡（发射）事件，然后在各节点设置监听，这里只要用 <code>$scope.$on()</code> 方法（注：如果在指令中，可能就是 <code>scope.$on()</code>），就可以进行监听了</li>
</ul>
<h3 id="scope轮循（生命周期）">Scope轮循（生命周期）</h3>
<p>浏览器接收一个事件的标准的工作流程应该是：</p>
<pre><code>接收事件 --&gt; 触发回调 --&gt; 回调执行结束返回 --&gt; 浏览器重绘DOM --&gt; 浏览器返回等待下一个事件</code></pre>
<p>上面的过程中，如果一切都发生在 ng 的执行上下文的话，那相安无事，ng 能够知道数据模型发生的改变；但是如果当浏览器的控制权跑到原生的 Js 中去时（译者注：比如回调是用jQuery做的之类的非 ng 的操作等），那么应用执行的上下文就发生在 ng 的上下文之外了，这样就导致 ng 无法知晓数据模型的任何改变。想要让 ng <em>重新掌权并知晓正在发生的数据模型的变化</em>的话，那就需要通过使用 <a href="api/ng.$rootScope.Scope#methods_$apply"><code><code>$apply</code></code></a> 方法让上下文执行环境重新进入到 ng 的上下文中（<em>注：用法 <code>$scope.$apply()</code></em>）。只有执行上下文重新回到 ng 中，那样数据模型的改变才能被 ng 所识别并作出相应操作（注：当然，如果执行上下文没有发生改变，也就没有必要显示地去进行 $apply 操作）。举个例子，像 <a href="api/ng.directive:ngClick"><code><code>ng-click</code></code></a> 这个指令，监听DOM事件时，表达式的计算就必须放在 <code>$apply()</code> 中（注：例子不够完备，待补充）。</p>
<p>After evaluating the expression, the <code>$apply</code> method performs a <a href="api/ng.$rootScope.Scope#methods_$digest"><code><code>$digest</code></code></a>. In the $digest phase the scope examines all
of the <code>$watch</code> expressions and compares them with the previous value. This dirty checking is done
asynchronously. This means that assignment such as <code>$scope.username=&quot;angular&quot;</code> will not
immediately cause a <code>$watch</code> to be notified, instead the <code>$watch</code> notification is delayed until
the <code>$digest</code> phase. This delay is desirable, since it coalesces multiple model updates into one
<code>$watch</code> notification as well as it guarantees that during the <code>$watch</code> notification no other
<code>$watch</code>es are running. If a <code>$watch</code> changes the value of the model, it will force additional
<code>$digest</code> cycle.</p>
<ol>
<li><p><strong>Creation</strong></p>
<p>The <a href="api/ng.$rootScope"><code>root scope</code></a> is created during the application
bootstrap by the <a href="api/AUTO.$injector"><code>$injector</code></a>. During template
linking, some directives create new child scopes.</p>
</li>
<li><p><strong>Watcher registration</strong></p>
<p>During template linking directives register <a href="api/ng.$rootScope.Scope#methods_$watch"><code>watches</code></a> on the scope. These watches will be
used to propagate model values to the DOM.</p>
</li>
<li><p><strong>Model mutation</strong></p>
<p>For mutations to be properly observed, you should make them only within the <a href="api/ng.$rootScope.Scope#methods_$apply"><code>scope.$apply()</code></a>. (Angular APIs do this
implicitly, so no extra <code>$apply</code> call is needed when doing synchronous work in controllers,
or asynchronous work with <a href="api/ng.$http"><code>$http</code></a> or <a href="api/ng.$timeout"><code>$timeout</code></a> services.</p>
</li>
<li><p><strong>Mutation observation</strong></p>
<p>At the end <code>$apply</code>, Angular performs a <a href="api/ng.$rootScope.Scope#methods_$digest"><code>$digest</code></a> cycle on the root scope, which then propagates throughout all child scopes. During
the <code>$digest</code> cycle, all <code>$watch</code>ed expressions or functions are checked for model mutation
and if a mutation is detected, the <code>$watch</code> listener is called.</p>
</li>
<li><p><strong>Scope destruction</strong></p>
<p>When child scopes are no longer needed, it is the responsibility of the child scope creator
to destroy them via <a href="api/ng.$rootScope.Scope#methods_$destroy"><code>scope.$destroy()</code></a>
API. This will stop propagation of <code>$digest</code> calls into the child scope and allow for memory
used by the child scope models to be reclaimed by the garbage collector.</p>
</li>
</ol>
<h4 id="scope轮循（生命周期）_scopes和指令">Scopes和指令</h4>
<p>During the compilation phase, the <a href="guide/compiler">compiler</a> matches <a href="api/ng.$compileProvider#methods_directive"><code>directives</code></a> against the DOM template. The directives
usually fall into one of two categories:</p>
<ul>
<li><p>Observing <a href="api/ng.$compileProvider#methods_directive"><code>directives</code></a>, such as
double-curly expressions <code>{{expression}}</code>, register listeners using the <a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch()</code></a> method. This type of directive needs
to be notified whenever the expression changes so that it can update the view.</p>
</li>
<li><p>Listener directives, such as <a href="api/ng.directive:ngClick"><code>ng-click</code></a>, register a listener with the DOM. When the DOM listener fires, the directive
executes the associated expression and updates the view using the <a href="api/ng.$rootScope.Scope#methods_$apply"><code>$apply()</code></a> method.</p>
</li>
</ul>
<p>When an external event (such as a user action, timer or XHR) is received, the associated <a href="guide/expression">expression</a> must be applied to the scope through the <a href="api/ng.$rootScope.Scope#methods_$apply"><code>$apply()</code></a> method so that all listeners are updated
correctly.</p>
<h4 id="scope轮循（生命周期）_可以创建scopes的指令">可以创建Scopes的指令</h4>
<p>In most cases, <a href="api/ng.$compileProvider#methods_directive"><code>directives</code></a> and scopes interact
but do not create new instances of scope. However, some directives, such as <a href="api/ng.directive:ngController"><code>ng-controller</code></a> and <a href="api/ng.directive:ngRepeat"><code>ng-repeat</code></a>, create new child scopes
and attach the child scope to the corresponding DOM element. You can retrieve a scope for any DOM
element by using an <code>angular.element(aDomElement).scope()</code> method call.</p>
<h4 id="scope轮循（生命周期）_scopes与控制器">Scopes与控制器</h4>
<p>Scopes and controllers interact with each other in the following situations:</p>
<ul>
<li><p>Controllers use scopes to expose controller methods to templates (see <a href="api/ng.directive:ngController"><code>ng-controller</code></a>).</p>
</li>
<li><p>Controllers define methods (behavior) that can mutate the model (properties on the scope).</p>
</li>
<li><p>Controllers may register <a href="api/ng.$rootScope.Scope#methods_$watch"><code>watches</code></a> on
the model. These watches execute immediately after the controller behavior executes.</p>
</li>
</ul>
<p>See the <a href="api/ng.directive:ngController"><code>ng-controller</code></a> for more
information.</p>
<h4 id="scope轮循（生命周期）_scope-性能">Scope <code>$watch</code> 性能</h4>
<p>Dirty checking the scope for property changes is a common operation in Angular and for this reason
the dirty checking function must be efficient. Care should be taken that the dirty checking
function does not do any DOM access, as DOM access is orders of magnitude slower then property
access on JavaScript object.</p>
<h3 id="与浏览器事件轮循整合">与浏览器事件轮循整合</h3>
<p><img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-runtime.png"></p>
<p>The diagram and the example below describe how Angular interacts with the browser&#39;s event loop.</p>
<ol>
<li>The browser&#39;s event-loop waits for an event to arrive. An event is a user interaction, timer event,
or network event (response from a server).</li>
<li>The event&#39;s callback gets executed. This enters the JavaScript context. The callback can
 modify the DOM structure.</li>
<li>Once the callback executes, the browser leaves the JavaScript context and
re-renders the view based on DOM changes.</li>
</ol>
<p>Angular modifies the normal JavaScript flow by providing its own event processing loop. This
splits the JavaScript into classical and Angular execution context. Only operations which are
applied in Angular execution context will benefit from Angular data-binding, exception handling,
property watching, etc... You can also use $apply() to enter Angular execution context from JavaScript. Keep in
mind that in most places (controllers, services) $apply has already been called for you by the
directive which is handling the event. An explicit call to $apply is needed only when
implementing custom event callbacks, or when working with third-party library callbacks.</p>
<ol>
<li>Enter Angular execution context by calling <a href="guide/scope">scope</a><code>.</code><a href="api/ng.$rootScope.Scope#methods_$apply"><code>$apply</code></a><code>(stimulusFn)</code>. Where <code>stimulusFn</code> is
the work you wish to do in Angular execution context.</li>
<li>Angular executes the <code>stimulusFn()</code>, which typically modifies application state.</li>
<li>Angular enters the <a href="api/ng.$rootScope.Scope#methods_$digest"><code>$digest</code></a> loop. The
loop is made up of two smaller loops which process <a href="api/ng.$rootScope.Scope#methods_$evalasync"><code>$evalAsync</code></a> queue and the <a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch</code></a> list. The <a href="api/ng.$rootScope.Scope#methods_$digest"><code>$digest</code></a> loop keeps iterating until the model
stabilizes, which means that the <a href="api/ng.$rootScope.Scope#methods_$evalasync"><code>$evalAsync</code></a> queue is empty and the <a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch</code></a> list does not detect any changes.</li>
<li>The <a href="api/ng.$rootScope.Scope#methods_$evalasync"><code>$evalAsync</code></a> queue is used to
schedule work which needs to occur outside of current stack frame, but before the browser&#39;s
view render. This is usually done with <code>setTimeout(0)</code>, but the <code>setTimeout(0)</code> approach
suffers from slowness and may cause view flickering since the browser renders the view after
each event.</li>
<li>The <a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch</code></a> list is a set of expressions
which may have changed since last iteration. If a change is detected then the <code>$watch</code>
function is called which typically updates the DOM with the new value.</li>
<li>Once the Angular <a href="api/ng.$rootScope.Scope#methods_$digest"><code>$digest</code></a> loop finishes
the execution leaves the Angular and JavaScript context. This is followed by the browser
re-rendering the DOM to reflect any changes.</li>
</ol>
<p>Here is the explanation of how the <code>Hello world</code> example achieves the data-binding effect when the
user enters text into the text field.</p>
<ol>
<li>During the compilation phase:<ol>
<li>the <a href="api/ng.directive:ngModel"><code>ng-model</code></a> and <a href="api/ng.directive:input"><code>input</code></a> <a href="guide/directive">directive</a> set up a <code>keydown</code> listener on the <code>&lt;input&gt;</code> control.</li>
<li>the <a href="api/ng.$interpolate"><code>&#123;&#123;name&#125;&#125;</code></a> interpolation
sets up a <a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch</code></a> to be notified of
<code>name</code> changes.</li>
</ol>
</li>
<li>During the runtime phase:<ol>
<li>Pressing an &#39;<code>X</code>&#39; key causes the browser to emit a <code>keydown</code> event on the input control.</li>
<li>The <a href="api/ng.directive:input"><code>input</code></a> directive
captures the change to the input&#39;s value and calls <a href="api/ng.$rootScope.Scope#methods_$apply"><code>$apply</code></a><code>(&quot;name = &#39;X&#39;;&quot;)</code> to update the
application model inside the Angular execution context.</li>
<li>Angular applies the <code>name = &#39;X&#39;;</code> to the model.</li>
<li>The <a href="api/ng.$rootScope.Scope#methods_$digest"><code>$digest</code></a> loop begins</li>
<li>The <a href="api/ng.$rootScope.Scope#methods_$watch"><code>$watch</code></a> list detects a change
on the <code>name</code> property and notifies the <a href="api/ng.$interpolate"><code>&#123;&#123;name&#125;&#125;</code></a> interpolation, which in turn updates the DOM.</li>
<li>Angular exits the execution context, which in turn exits the <code>keydown</code> event and with it
the JavaScript execution context.</li>
<li>The browser re-renders the view with update text.</li>
</ol>
</li>
</ol>
</div></div>
