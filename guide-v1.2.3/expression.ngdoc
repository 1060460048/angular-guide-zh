@ngdoc overview
@name 开发人员指南: 表达式(Expressions)
@description
翻译者:[@NigelYao](https://github.com/NigelYao)

"表达式"是一种类似JavaScript的代码片段，通常在视图中以'{{ expression }}'的形式使用。表达式由{@link api/ng.$parse $parse}服务解析，而解析之后经常会使用{@link filter 过滤器}来格式化成一种更加用户友好的形式。

例如，下面这些都是Angular中合法的表达式：
  
  * `1+2`
  * `user.name`
  * `user.name`
  * `items[index]`

## Angular表达式与JS表达式 

可能会有人认为Angular视图表达式就是JavaScript表达式，但这不完全正确，因为Angular并没有使用JavaScript中的'eval()'来解析表达式。你可以认为Angular表达式与JavaScript表达式有如下的区别：

  * **属性解析：** 所有的属性的解析都是相对于作用域(scope)的，而不像JavaScript中的表达式解析那样是相对于全局'window'对象的。

  * **容错性：** 表达式的解析对'undefined'和'null'具有容错性，这不像在JavaScript中，试图解析未定义的属性时会抛出`ReferenceError`或`TypeError`错误.

  * **禁止控制流语句：** 表达式中不允许包括下列语句：条件判断(if)，循环(for/while)，抛出异常(throw)。

另一方面，如果你想执行特定的JavaScript代码，你应该在一个控制器里导出一个方法，然后在模板中调用这个方法。如果你想在JavaScript中解析一个Angular表达式，使用{@link api/ng.$rootScope.Scope#methods_$eval `$eval()`}方法。

## 例子

<doc:example>
<doc:source>
 1+2={{1+2}}
</doc:source>
<doc:scenario>
 it('should calculate expression in binding', function() {
   expect(binding('1+2')).toEqual('3');
 });
</doc:scenario>
</doc:example>

你可以在此处试一试解析其他的表达式：

<example module="expressionExample">
  <file name="index.html">
    <div ng-controller="ExampleController" class="expressions">
      Expression:
      <input type='text' ng-model="expr" size="80"/>
      <button ng-click="addExp(expr)">Evaluate</button>
      <ul>
       <li ng-repeat="expr in exprs track by $index">
         [ <a href="" ng-click="removeExp($index)">X</a> ]
         <tt>{{expr}}</tt> => <span ng-bind="$parent.$eval(expr)"></span>
        </li>
      </ul>
    </div>
  </file>

  <file name="script.js">
    angular.module('expressionExample', [])
      .controller('ExampleController', ['$scope', function($scope) {
        var exprs = $scope.exprs = [];
        $scope.expr = '3*10|currency';
        $scope.addExp = function(expr) {
          exprs.push(expr);
        };

        $scope.removeExp = function(index) {
          exprs.splice(index, 1);
        };
      }]);
  </file>

  <file name="protractor.js" type="protractor">
    it('should allow user expression testing', function() {
      element(by.css('.expressions button')).click();
      var lis = element(by.css('.expressions ul')).all(by.repeater('expr in exprs'));
      expect(lis.count()).toBe(1);
      expect(lis.get(0).getText()).toEqual('[ X ] 3*10|currency => $30.00');
    });
  </file>
</example>


# 作用域

表达式的作用域是scope上。不像在JavaScript中，将默认的作用域放在全局的window对象中，Angular表达式必须使用{@link api/ng.$window
`$window`}来指向全局的'window'对象。例如，如果你想调用在'window'上定义的'alert()'方法，在表达式中，你必须使用'$window.alert()'。作者故意这样设定，就是为了防止对全局状态非正常的访问（一些奇怪bug的常见来源）。

<example module="expressionExample">
  <file name="index.html">
    <div class="example2" ng-controller="ExampleController">
      Name: <input ng-model="name" type="text"/>
      <button ng-click="greet()">Greet</button>
      <button ng-click="window.alert('Should not see me')">Won't greet</button>
    </div>
  </file>

  <file name="script.js">
    angular.module('expressionExample', [])
      .controller('ExampleController', ['$window', '$scope', function($window, $scope) {
        $scope.name = 'World';

        $scope.greet = function() {
          $window.alert('Hello ' + $scope.name);
        };
      }]);
  </file>

  <file name="protractor.js" type="protractor">
    it('should calculate expression in binding', function() {
      if (browser.params.browser == 'safari') {
        // Safari can't handle dialogs.
        return;
      }
      element(by.css('[ng-click="greet()"]')).click();

      var alertDialog = browser.switchTo().alert();

      expect(alertDialog.getText()).toEqual('Hello World');

      alertDialog.accept();
    });
  </file>
</example>

## 容错性

表达式的解析对undefined和null具有容错性。在JavaScript中，解析'a,b,c'时，如果'a'不是一个对象会抛出异常。在一些语言中这可能会有用，但表达式的解析在Angular中主要用在数据绑定上，我们会像下面这样使用表达式：

        {{a.b.c}}

此时如果'a'是未定义的（也许我们正等着服务器响应数据，在不久的将来其会被定义），解析抛出异常将不再合理。如果表达式不具有容错性的话，我们的代码会变的繁杂且影响阅读，例如：`{{((a||{}).b||{}).c}}`。

类似的，在undefined和null的对象上调用方法'a.b.c()'时会返回undefined。

## 禁止控制流语句

在表达式中禁止写控制流语句。这背后的原因在于，Angular设计哲学的核心认为，应用逻辑应该在控制器中，而不是在视图中控制。如果你需要条件表达式，循环或者抛出异常出现在你的视图表达式中，请将其委托到JavaScript方法中执行。

## `$event`

Directives like {@link ng.directive:ngClick `ngClick`} and {@link ng.directive:ngFocus `ngFocus`}
expose a `$event` object within the scope of that expression.

<example module="eventExampleApp">
  <file name="index.html">
    <div ng-controller="EventController">
      <button ng-click="clickMe($event)">Event</button>
      <p><code>$event</code>: <pre> {{$event | json}}</pre></p>
      <p><code>clickEvent</code>: <pre>{{clickEvent | json}}</pre></p>
    </div>
  </file>

  <file name="script.js">
    angular.module('eventExampleApp', []).
      controller('EventController', ['$scope', function($scope) {
        /*
         * expose the event object to the scope
         */
        $scope.clickMe = function(clickEvent) {
          $scope.clickEvent = simpleKeys(clickEvent);
          console.log(clickEvent);
        };

        /*
         * return a copy of an object with only non-object keys
         * we need this to avoid circular references
         */
        function simpleKeys (original) {
          return Object.keys(original).reduce(function (obj, key) {
            obj[key] = typeof original[key] === 'object' ? '{ ... }' : original[key];
            return obj;
          }, {});
        }
      }]);
  </file>
</example>

Note in the example above how we can pass in `$event` to `clickMe`, but how it does not show up
in `{{$event}}`. This is because `$event` is outside the scope of that binding.


## One-time binding

An expression that starts with `::` is considered a one-time expression. One-time expressions
will stop recalculating once they are stable, which happens after the first digest if the expression
result is a non-undefined value (see value stabilization algorithm below).

<example module="oneTimeBidingExampleApp">
  <file name="index.html">
    <div ng-controller="EventController">
      <button ng-click="clickMe($event)">Click Me</button>
      <p id="one-time-binding-example">One time binding: {{::name}}</p>
      <p id="normal-binding-example">Normal binding: {{name}}</p>
    </div>
  </file>
  <file name="script.js">
    angular.module('oneTimeBidingExampleApp', []).
      controller('EventController', ['$scope', function($scope) {
        var counter = 0;
        var names = ['Igor', 'Misko', 'Chirayu', 'Lucas'];
        /*
         * expose the event object to the scope
         */
        $scope.clickMe = function(clickEvent) {
          $scope.name = names[counter % names.length];
          counter++;
        };
      }]);
  </file>
  <file name="protractor.js" type="protractor">
    it('should freeze binding after its value has stabilized', function() {
      var oneTimeBiding = element(by.id('one-time-binding-example'));
      var normalBinding = element(by.id('normal-binding-example'));

      expect(oneTimeBiding.getText()).toEqual('One time binding:');
      expect(normalBinding.getText()).toEqual('Normal binding:');
      element(by.buttonText('Click Me')).click();

      expect(oneTimeBiding.getText()).toEqual('One time binding: Igor');
      expect(normalBinding.getText()).toEqual('Normal binding: Igor');
      element(by.buttonText('Click Me')).click();

      expect(oneTimeBiding.getText()).toEqual('One time binding: Igor');
      expect(normalBinding.getText()).toEqual('Normal binding: Misko');

      element(by.buttonText('Click Me')).click();
      element(by.buttonText('Click Me')).click();

      expect(oneTimeBiding.getText()).toEqual('One time binding: Igor');
      expect(normalBinding.getText()).toEqual('Normal binding: Lucas');
    });
  </file>
</example>


### Why this feature

The main purpose of one-time binding expression is to provide a way to create a binding
that gets deregistered and frees up resources once the binding is stabilized.
Reducing the number of expressions being watched makes the digest loop faster and allows more
information to be displayed at the same time.


### Value stabilization algorithm

One-time binding expressions will retain the value of the expression at the end of the
digest cycle as long as that value is not undefined. If the value of the expression is set
within the digest loop and later, within the same digest loop, it is set to undefined,
then the expression is not fulfilled and will remain watched.

  1. Given an expression that starts with `::` when a digest loop is entered and expression
     is dirty-checked store the value as V
  2. If V is not undefined mark the result of the expression as stable and schedule a task
     to deregister the watch for this expression when we exit the digest loop
  3. Process the digest loop as normal
  4. When digest loop is done and all the values have settled process the queue of watch
     deregistration tasks. For each watch to be deregistered check if it still evaluates
     to value that is not `undefined`. If that's the case, deregister the watch. Otherwise
     keep dirty-checking the watch in the future digest loops by following the same
     algorithm starting from step 1


### How to benefit from one-time binding

When interpolating text or attributes. If the expression, once set, will not change
then it is a candidate for one-time expression.

```html
  <div name="attr: {{::color}}">text: {{::name}}</div>
```

When using a directive with bidirectional binding and the parameters will not change

```js
someModule.directive('someDirective', function() {
  return {
    scope: {
      name: '=',
      color: '@'
    },
    template: '{{name}}: {{color}}'
  };
});
```

```html
  <div some-directive name=“::myName” color=“My color is {{::myColor}}”></div>
```


When using a directive that takes an expression

```html
<ul>
  <li ng-repeat="item in ::items">{{item.name}};</li>
</ul>
```
