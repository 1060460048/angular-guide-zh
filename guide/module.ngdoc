@ngdoc overview
@name Developer Guide: Modules
@description

Translated by [@GrahamLe](https://github.com/grahamle)

# 何为模块？

大多数应用程序都有个 `main` 函数来初始化、连接以及启动整个应用。ng 中虽然没有 `main` 函数，它用模块来指定应用需要如何启动。这种策略有如下几种优势：

  * 整个过程是声明式的，更容易理解
  * 在单元测试中，没有必要加载所有模块，这样有利于单元测试的代码书写
  * 在场景测试中，额外的模块可以被加载进来进而重写一些配置，这样有助于应用的端到端的测试
  * 第三方代码可以很容易被打包作为可重用的模块
  * 模块可以以任何或是并行的顺序被加载（得益于模块执行的延迟性）

# 模块ABC

你会说，别废话一箩筐了，说个 Hello World 的模块示例吧，让它跑起来才是王道呀。

可以，在此之前，有几件重要的事情必须记住：

  * {@link api/angular.Module Module} API
  * 在 `<html ng-app="myApp">` ，注意对于 `myApp` 模块的引用，这是用模块的方法启动应用的触发点

<doc:example module='myApp'>
  <doc:source>
    <script>
      // 声明一个模块
      var myAppModule = angular.module('myApp', []);

      // 模块配置
      // 在这个例子中，我们创建一个过滤器
      myAppModule.filter('greet', function() {
       return function(name) {
          return 'Hello, ' + name + '!';
        };
      });

    </script>
    <div>
      {{ 'World' | greet }}
    </div>
  </doc:source>
</doc:example>



# 推荐配置

上面的例子太过简单了，对于大型应用显然不适用。对于大型app，我们推荐将应用像如下分为多个模块：

  * 服务模块
  * 指令模块
  * 过滤器模块
  * 一个应用级的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码

这样划分模块的原因主要是在你的测试中，经常需要忽略难以测试的初始化的代码，而且这样测试时可以单个加载模块进行相关的测试。

上述模块划分仅仅是一种建议性的方案，你可以根据自己app的需要去调整。下面的代码显示了上面所述的模块划分：

<doc:example module='xmpl'>
  <doc:source>
    <script>
      angular.module('xmpl.service', []).
        value('greeter', {
          salutation: 'Hello',
          localize: function(localization) {
            this.salutation = localization.salutation;
          },
          greet: function(name) {
            return this.salutation + ' ' + name + '!';
          }
        }).
        value('user', {
          load: function(name) {
            this.name = name;
          }
        });

      angular.module('xmpl.directive', []);

      angular.module('xmpl.filter', []);

      angular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']).
        run(function(greeter, user) {
          // This is effectively part of the main method initialization code
          greeter.localize({
            salutation: 'Bonjour'
          });
          user.load('World');
        })


      // A Controller for your app
      var XmplController = function($scope, greeter, user) {
        $scope.greeting = greeter.greet(user.name);
      }
    </script>
    <div ng-controller="XmplController">
      {{ greeting }}!
    </div>
  </doc:source>
 </doc:example>



# 模块加载及依赖

A module is a collection of configuration and run blocks which get applied to the application
during the bootstrap process. In its simplest form the module consist of collection of two kinds
of blocks:

  1. **Configuration blocks** - get executed during the provider registrations and configuration
    phase. Only providers and constants can be injected into configuration blocks. This is to
    prevent accidental instantiation of services before they have been fully configured.
  2. **Run blocks** - get executed after the injector is created and are used to kickstart the
    application. Only instances and constants can be injected into run blocks. This is to prevent
    further system configuration during application run time.

<pre>
angular.module('myModule', []).
  config(function(injectables) { // provider-injector
    // This is an example of config block.
    // You can have as many of these as you want.
    // You can only inject Providers (not instances)
    // into the config blocks.
  }).
  run(function(injectables) { // instance-injector
    // This is an example of a run block.
    // You can have as many of these as you want.
    // You can only inject instances (not Providers)
    // into the run blocks
  });
</pre>

## 配置代码块

There are some convenience methods on the module which are equivalent to the config block. For
example:

<pre>
angular.module('myModule', []).
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// is same as

angular.module('myModule', []).
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { return 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });
</pre>

The configuration blocks get applied in the order in which they are registered. The only exception
to it are constant definitions, which are placed at the beginning of all configuration blocks.

## 执行代码块

Run blocks are the closest thing in Angular to the main method. A run block is the code which
needs to run to kickstart the application. It is executed after all of the service have been
configured and the injector has been created. Run blocks typically contain code which is hard
to unit-test, and for this reason should be declared in isolated modules, so that they can be
ignored in the unit-tests.

## 依赖

Modules can list other modules as their dependencies. Depending on a module implies that required
module needs to be loaded before the requiring module is loaded. In other words the configuration
blocks of the required modules execute before the configuration blocks of the requiring module.
The same is true for the run blocks. Each module can only be loaded once, even if multiple other
modules require it.

## 异步加载

Modules are a way of managing $injector configuration, and have nothing to do with loading of
scripts into a VM. There are existing projects which deal with script loading, which may be used
with Angular. Because modules do nothing at load time they can be loaded into the VM in any order
and thus script loaders can take advantage of this property and parallelize the loading process.

## Creation versus Retrieval

Beware that using `angular.module('myModule', [])` will create the module `myModule` and overwrite any
existing module named `myModule`. Use `angular.module('myModule')` to retrieve an existing module.

<pre>
  var myModule = angular.module('myModule', []);
  
  // add some directives and services
  myModule.service('myService', ...);
  myModule.directive('myDirective', ...);

  // overwrites both myService and myDirective by creating a new module
  var myModule = angular.module('myModule', []);

  // throws an error because myOtherModule has yet to be defined
  var myModule = angular.module('myOtherModule');
</pre>

# 单元测试

In its simplest form a unit test is a way of instantiating a subset of the application in test and
then applying a stimulus to it. It is important to realize that each module can only be loaded
once per injector. Typically an app has only one injector. But in tests, each test has its own
injector, which means that the modules are loaded multiple times per VM. Properly structured
modules can help with unit testing, as in this example:

In all of these examples we are going to assume this module definition:
<pre>
  angular.module('greetMod', []).

    factory('alert', function($window) {
      return function(text) {
        $window.alert(text);
      }
    }).

    value('salutation', 'Hello').

    factory('greet', function(alert, salutation) {
      return function(name) {
        alert(salutation + ' ' + name + '!');
      }
    });
</pre>

Let's write some tests:
<pre>
describe('myApp', function() {
  // load the relevant application modules then load a special
  // test module which overrides the $window with a mock version,
  // so that calling window.alert() will not block the test
  // runner with a real alert box. This is an example of overriding
  // configuration information in tests.
  beforeEach(module('greetMod', function($provide) {
    $provide.value('$window', {
      alert: jasmine.createSpy('alert')
    });
  }));

  // The inject() will create the injector and inject the greet and
  // $window into the tests. The test need not concern itself with
  // wiring of the application, only with testing it.
  it('should alert on $window', inject(function(greet, $window) {
    greet('World');
    expect($window.alert).toHaveBeenCalledWith('Hello World!');
  }));

  // this is another way of overriding configuration in the
  // tests using an inline module and inject methods.
  it('should alert using the alert service', function() {
    var alertSpy = jasmine.createSpy('alert');
    module(function($provide) {
      $provide.value('alert', alertSpy);
    });
    inject(function(greet) {
      greet('World');
      expect(alertSpy).toHaveBeenCalledWith('Hello World!');
    });
  });
});
</pre>
