@ngdoc overview
@name Controllers
@description

Translated by [@GrahamLe](https://github.com/grahamle)

# 理解控制器

在 ng 中，控制器就像 Js 中的**构造函数**一般，是用来增强 {@link scope Angular Scope} 的。

当一个控制器通过 {@link api/ng.directive:ngController ng-controller} 指令被添加到DOM中时，ng 会调用该指令所特指的控制器的**构造函数**初始化一个控制器对象，这样，一个新的**子级 scope**就被创建，在控制器的构造函数中，scope 就可以作为一个参数注入其中并被调用，注入及调用方式为 `$scope`。

一般情况下，我们使用控制器做两件事：

- 设置 `$scope` 对象的初始状态
- 为 `$scope` 对象添加行为（方法）

# 设置 `$scope` 对象的初始状态

通常，当我们创建应用时，我们需要为 ng 的 `$scope` 对象设置初始状态，而这，都是通过往 `$scope` 对象上添加属性。被添加的属性包含着要在视图中展示的数据对象（注：原文称**view model**）。所有被添加注册到 `$scope` 对象下的属性，在控制器被注册到的DOM的模版中，均可以获得。

接下来一个示例展示了一个简单的构造函数来描述控制器，称它为 `GreetingCtrl`，我们在该控制器所创建的 scope 中添加了一个 `greeting` 属性：

<pre>
    function GreetingCtrl($scope) {
        $scope.greeting = 'Hola!';
    }
</pre>

按上述这样，我们有了一个控制器，它初始化了一个 `$scope` 并且拥有一个属性，当我们把该控制器添加到DOM中后，这个 `greeting` 属性就可以通过下面的HTML模版的数据绑定引用获得了，然后浏览器可以解释渲染输出了：

<pre>
    <div ng-controller="GreetingCtrl">
      {{ greeting }}
    </div>
</pre>

**注意**：虽然 ng 允许我们在全局作用域下创建控制器的构造函数，但是这种方式并不被推荐。在一个实际应用程序开发中，推荐使用在 {@link module Angular Module} 下通过 `.controller` 为你的应用创建控制器，如下面例子：

<pre>
    var myApp = angular.module('myApp',[]);

    myApp.controller('GreetingCtrl', ['$scope', function($scope) {
        $scope.greeting = 'Hola!';
    }]);
</pre>

在上面例子中，我们使用了一个**行内注入依赖**的方法显性地声明了 `GreetingCtrl` 依赖于 ng 提供的 `$scope` 服务。另见 {@link http://docs.angularjs.org/guide/di Dependency Injection} 查阅更多详细信息。


# 为 `$scope` 对象添加行为

为了对事件作出响应，或是在视图中执行计算，我们需要为 scope 提供相关的行为操作的逻辑。上面一节中，我们为 scope 添加属性来让DOM模版可以获取数据模型，现在，我们为 `$scope` 添加方法来让 scope 能够进行相关的行为操作逻辑。添加完之后，这些方法就可以在**模版/视图**中被调用了。

下述例子展示了一个为控制器中的 scope 添加方法，这个方法用来使一个数字翻倍：

<pre>
    var myApp = angular.module('myApp',[]);

    myApp.controller('DoubleCtrl', ['$scope', function($scope) {
        $scope.double = function(value) { return value * 2; };
    }]);
</pre>

当上述控制器被添加到DOM之后，`double` 方法即可被调用，如在模版中的一个 ng 表达式中：

<pre>
    <div ng-controller="DoubleCtrl">
      Two times <input ng-model="num"> equals {{ double(num) }}
    </div>
</pre>

如本指南 {@link concepts Concepts} 部分所指出的一样，任何对象（或者基础类型的变量）被添加到 scope 都将成为 scope 的属性，作为数据模型供模版/视图调用。任何方法被添加到 scope ，也能在模版/视图中通过 ng 表达式或是 ng 的事件处理器（如：{@link api/ng.directive:ngClick ngClick}）调用。

# 正确使用控制器

通常情况下，控制器不应该被赋予太多的责任和义务，也就是不应该做太多事情。控制器只需要负责一个单一的视图所需要的业务逻辑。

最常见的保持控制器纯粹的方法是将那些不属于控制器的逻辑都封装在服务（services）中，然后在控制器中通过依赖注入调用相关服务。详见指南中的 {@link di Dependency Injection} {@link dev_guide.services Services} 这两部分。

注意，下面有几个场合**千万不要用控制器**：

- 任何形式的DOM操作：控制器只包含业务逻辑操作（注：最纯粹的情况下）。DOM操作时属于应用程序的表现层逻辑操作，向来以测试难度高闻名于业界。把任何表现层的逻辑放到控制器中会大大增加了业务逻辑的测试难度。ng 提供数据绑定 （{@link databinding databinding}） 来进行自动化的DOM操作。如果需要手动进行DOM操作，那么最好将表现层的逻辑封装在指令 {@link guide/directive directives} 中
- 格式化输入：相反，使用 {@link forms angular form controls} 替代
- 过滤输出：使用 ng 的 {@link filter angular filters} 替代
- 跨控制器间共享有状态或无状态代码：使用噢乖 {@link dev_guide.services angular services} 替代（注：此处有状态及无状态代码不确定）
- 管理其它组成部分的生命周期（如创建 service 对象实例）


# 将控制器与 scope 对象关联

通过两种方法可以实现控制器和 scope 对象的关联：

- {@link api/ng.directive:ngController ngController directive} 这个指令就是创建了一个新的 scope
- {@link api/ngRoute.$route $route service}


## 简单的控制器示例

为了更深入地阐释 ng 的控制器是如何工作的，我们用如下几个组成部分来构建一个小的app：

- 一个由两个按钮和一个简单消息构成的模版 {@link templates template}
- 一个名为 `spice` 的数据模型对象，是一个字符串
- 一个拥有两个方法的控制器，可以设置数据模型对象（scope 的属性）`spice` 的值

The message in our template contains a binding to the `spice` model, which by default is set to the
string "very". Depending on which button is clicked, the `spice` model is set to `chili` or
`jalapeño`, and the message is automatically updated by data-binding.

<doc:example module="spicyApp1">
  <doc:source>
    <div ng-app="spicyApp1" ng-controller="SpicyCtrl">
     <button ng-click="chiliSpicy()">Chili</button>
     <button ng-click="jalapenoSpicy()">Jalapeño</button>
     <p>The food is {{spice}} spicy!</p>
    </div>
    <script>
      var myApp = angular.module('spicyApp1', []);

      myApp.controller('SpicyCtrl', ['$scope', function($scope){
          $scope.spice = 'very';
          
          $scope.chiliSpicy = function() {
              $scope.spice = 'chili';
          };
          
          $scope.jalapenoSpicy = function() {
              $scope.spice = 'jalapeño';
          };
      }]);
    </script>
  </doc:source>
</doc:example>

Things to notice in the example above:

- The `ng-controller` directive is used to (implicitly) create a scope for our template, and the
scope is augmented (managed) by the `SpicyCtrl` Controller.
- `SpicyCtrl` is just a plain JavaScript function. As an (optional) naming convention the name
starts with capital letter and ends with "Ctrl" or "Controller".
- Assigning a property to `$scope` creates or updates the model.
- Controller methods can be created through direct assignment to scope (see the `chiliSpicy` method)
- The Controller methods and properties are available in the template (for the `<div>` element and
and its children).

## Spicy Arguments Example

Controller methods can also take arguments, as demonstrated in the following variation of the
previous example.

<doc:example module="spicyApp2">
  <doc:source>
  <div ng-app="spicyApp2" ng-controller="SpicyCtrl">
   <input ng-model="customSpice">
   <button ng-click="spicy('chili')">Chili</button>
   <button ng-click="spicy(customSpice)">Custom spice</button>
   <p>The food is {{spice}} spicy!</p>
  </div>
  <script>
    var myApp = angular.module('spicyApp2', []);

    myApp.controller('SpicyCtrl', ['$scope', function($scope){
        $scope.customSpice = "wasabi";
        $scope.spice = 'very';
        
        $scope.spicy = function(spice){
            $scope.spice = spice;
        };
    }]);
  </script>
</doc:source>
</doc:example>

Notice that the `SpicyCtrl` Controller now defines just one method called `spicy`, which takes one
argument called `spice`. The template then refers to this Controller method and passes in a string
constant `'chili'` in the binding for the first button and a model property `customSpice` (bound to an
input box) in the second button.

## Scope 继承示例

It is common to attach Controllers at different levels of the DOM hierarchy.  Since the 
{@link api/ng.directive:ngController ng-controller} directive creates a new child scope, we get a
hierarchy of scopes that inherit from each other.  The `$scope` that each Controller receives will
have access to properties and methods defined by Controllers higher up the hierarchy.
See {@link https://github.com/angular/angular.js/wiki/Understanding-Scopes Understanding Scopes} for
more information about scope inheritance.

<doc:example module="scopeInheritance">
  <doc:source>
    <div ng-app="scopeInheritance" class="spicy">
      <div ng-controller="MainCtrl">
        <p>Good {{timeOfDay}}, {{name}}!</p>

        <div ng-controller="ChildCtrl">
          <p>Good {{timeOfDay}}, {{name}}!</p>

          <div ng-controller="GrandChildCtrl">
            <p>Good {{timeOfDay}}, {{name}}!</p>
          </div>
        </div>
      </div>
    </div>
    <style>
      div.spicy div {
        padding: 10px;
        border: solid 2px blue;
      }
    </style>
    <script>
      var myApp = angular.module('scopeInheritance', []);
      myApp.controller('MainCtrl', ['$scope', function($scope){
        $scope.timeOfDay = 'morning';
        $scope.name = 'Nikki';
      }]);
      myApp.controller('ChildCtrl', ['$scope', function($scope){
        $scope.name = 'Mattie';
      }]);
      myApp.controller('GrandChildCtrl', ['$scope', function($scope){
        $scope.timeOfDay = 'evening';
        $scope.name = 'Gingerbreak Baby';
      }]);
    </script>
  </doc:source>
</doc:example>

Notice how we nested three `ng-controller` directives in our template. This will result in four
scopes being created for our view:

- The root scope
- The `MainCtrl` scope, which contains `timeOfDay` and `name` properties
- The `ChildCtrl` scope, which inherits the `timeOfDay` property but overrides (hides) the `name`
property from the previous
- The `GrandChildCtrl` scope, which overrides (hides) both the `timeOfDay` property defined in `MainCtrl`
and the `name` property defined in `ChildCtrl`

Inheritance works with methods in the same way as it does with properties. So in our previous
examples, all of the properties could be replaced with methods that return string values.


## 控制器测试

Although there are many ways to test a Controller, one of the best conventions, shown below,
involves injecting the {@link api/ng.$rootScope $rootScope} and {@link api/ng.$controller $controller}:

**Controller Definition:**
<pre>
    var myApp = angular.module('myApp',[]);

    myApp.controller('MyController', function($scope) {
      $scope.spices = [{"name":"pasilla", "spiciness":"mild"},
                       {"name":"jalapeno", "spiceiness":"hot hot hot!"},
                       {"name":"habanero", "spiceness":"LAVA HOT!!"}];
      $scope.spice = "habanero";
    });
</pre>

**Controller Test:**
<pre>
describe('myController function', function() {

  describe('myController', function() {
    var $scope;

    beforeEach(module('myApp'));

    beforeEach(inject(function($rootScope, $controller) {
      $scope = $rootScope.$new();
      $controller('MyController', {$scope: $scope});
    }));

    it('should create "spices" model with 3 spices', function() {
      expect($scope.spices.length).toBe(3);
    });

    it('should set the default value of spice', function() {
      expect($scope.spice).toBe('habanero');
    });
  });
});
</pre>


If you need to test a nested Controller you need to create the same scope hierarchy
in your test that exists in the DOM:

<pre>
describe('state', function() {
    var mainScope, childScope, grandChildScope;

    beforeEach(module('myApp'));

    beforeEach(inject(function($rootScope, $controller) {
        mainScope = $rootScope.$new();
        $controller('MainCtrl', {$scope: mainScope});
        childScope = mainScope.$new();
        $controller('ChildCtrl', {$scope: childScope});
        grandChildScope = childScope.$new();
        $controller('GrandChildCtrl', {$scope: grandChildScope});
    }));

    it('should have over and selected', function() {
        expect(mainScope.timeOfDay).toBe('morning');
        expect(mainScope.name).toBe('Nikki');
        expect(childScope.timeOfDay).toBe('morning');
        expect(childScope.name).toBe('Mattie');
        expect(grandChildScope.timeOfDay).toBe('evening');
        expect(grandChildScope.name).toBe('Gingerbreak Baby');
    });
});
</pre>



