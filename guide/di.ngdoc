@ngdoc overview
@name Developer Guide: Dependency Injection
@description

Translated by [@GrahamLe](https://github.com/grahamle)

# 依赖注入

依赖注入（译注：以下简称DI）是一种让代码处理其依赖关系的软件设计模式。

期待更多详细的有关 `DI` 的讨论，请看维基百科的 {@link http://en.wikipedia.org/wiki/Dependency_injection Dependency Injection} 词条，以及 Martin Fowler 写的 {@link http://martinfowler.com/articles/injection.html Inversion of Control} ，或者是在你喜欢的任何一本设计模式的书去查看。

## DI简介

对象或是函数只有三种方式可以得到依赖：

  1. 依赖创建，通常是通过 `new` 操作符

  2. 依赖查找，通过引用一个全局变量

  3. 依赖传递，依赖可以被注入到任何需要依赖的地方

前两种选择：创建或是查找依赖都不是那么理想，因为它们都是将依赖写死在对象或函数里了。不能说完全没可能吧，但至少，想要更改上述两种方式得到的依赖是很困难的。尤其是在测试的时候，会遇到很多问题，因为测试时常常需要我们提供模拟的依赖（译注：此句涉及测试，本人不精，已跪）。

第三种方式是最可行的，因为它去除了去组件里面定位相应的依赖这个担子，而是反过来，依赖总是能够很简单地被注入到需要它的组件中。（译注：说实话，上述三种方式，说的啥玩意呀，对于我是相当于没说一样）

<pre>
  function SomeClass(greeter) {
    this.greeter = greeter;
  }
  
  SomeClass.prototype.doSomething = function(name) {
    this.greeter.greet(name);
  }
</pre>

上述例子中，`SomeClass` 不必去在意 `greeter` 依赖是从哪里来的，反正就是在运行的时候，`greeter` 依赖被传进来了，我用就是了。（译注：so easy，妈妈再也不用担心我的依赖了）

像这个例子中的情况是我们愿意看到的，但是它把获得依赖的大部分责任都放在了我们创建 `SomeClass` 的代码中。

<img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-module-injector.png">

为了分配依赖创建的任务，每个 Angular 应用都有一个 {@link api/angular.injector injector}。这个 `injector` 是一个服务定位器，负责创建和查找依赖的。（译注：当你的app的某处声明需要用到某个依赖时，Angular 会调用这个依赖注入器去查找或是创建你所需要的依赖，然后返回来给你用）

下面是一个利用 `injector` 服务例子：

<pre>
  // Provide the wiring information in a module
  angular.module('myModule', []).
  
    // 下面是教 injector 如何构建一个 'greeter' 依赖
    // 注意 greeter 本身依赖于 '$window'
    factory('greeter', function($window) {
      // 这是一个 factory 函数，负责创建 'greeter' 服务 
      return {
        greet: function(text) {
          $window.alert(text);
        }
      };
    });

  // 从 module 创建的 injector 
  // 这个常常是 Angular 启动时自动完成的
  var injector = angular.injector(['myModule', 'ng']);
  
  // 通过 injector 请求任意的依赖
  var greeter = injector.get('greeter');
</pre>

Asking for dependencies solves the issue of hard coding, but it also means that the injector needs
to be passed throughout the application. Passing the injector breaks the {@link
http://en.wikipedia.org/wiki/Law_of_Demeter Law of Demeter}. To remedy this, we turn the
dependency lookup responsibility to the injector by declaring the dependencies as in this example:

<pre>
  <!-- Given this HTML -->
  <div ng-controller="MyController">
    <button ng-click="sayHello()">Hello</button>
  </div>
</pre>  
<pre>
  // And this controller definition
  function MyController($scope, greeter) {
    $scope.sayHello = function() {
      greeter.greet('Hello World');
    };
  }
  
  // The 'ng-controller' directive does this behind the scenes
  injector.instantiate(MyController);
</pre>

Notice that by having the `ng-controller` instantiate the class, it can satisfy all of the
dependencies of `MyController` without the controller ever knowing about the injector. This is
the best outcome. The application code simply asks for the dependencies it needs, without having to
deal with the injector. This setup does not break the Law of Demeter.

## Dependency Annotation

How does the injector know what service needs to be injected?

The application developer needs to provide annotation information that the injector uses in order
to resolve the dependencies. Throughout Angular, certain API functions are invoked using the
injector, as per the API documentation. The injector needs to know what services to inject into
the function. Below are three equivalent ways of annotating your code with service name
information. These can be used interchangeably as you see fit and are equivalent.

### Inferring Dependencies

The simplest way to get hold of the dependencies, is to assume that the function parameter names
are the names of the dependencies.

<pre>
  function MyController($scope, greeter) {
    ...
  }
</pre>

Given a function the injector can infer the names of the service to inject by examining the
function declaration and extracting the parameter names. In the above example `$scope`, and
`greeter` are two services which need to be injected into the function.

While straightforward, this method will not work with JavaScript minifiers/obfuscators as they
rename the method parameter names. This makes this way of annotating only useful for {@link
http://www.pretotyping.org/ pretotyping}, and demo applications.

### `$inject` Annotation

To allow the minifers to rename the function parameters and still be able to inject right services
the function needs to be annotated with the `$inject` property. The `$inject` property is an array
of service names to inject.

<pre>
  var MyController = function(renamed$scope, renamedGreeter) {
    ...
  }
  MyController['$inject'] = ['$scope', 'greeter'];
</pre>

In this scenario the ordering of the values in the '$inject' array must match the ordering of the arguments to inject.
Using above code snippet as an example, '$scope' will be injected into 'renamed$scope' and 'greeter' into 'renamedGreeter'.
Care must be taken that the `$inject` annotation is kept in sync with the actual arguments in the
function declaration.

This method of annotation is useful for controller declarations since it assigns the annotation
information with the function.

### Inline Annotation

Sometimes using the `$inject` annotation style is not convenient such as when annotating
directives.

For example:

<pre>
  someModule.factory('greeter', function($window) {
    ...
  });
</pre>

Results in code bloat due to needing a temporary variable:

<pre>
  var greeterFactory = function(renamed$window) {
    ...
  };
  
  greeterFactory.$inject = ['$window'];
  
  someModule.factory('greeter', greeterFactory);
</pre>

For this reason the third annotation style is provided as well.

<pre>
  someModule.factory('greeter', ['$window', function(renamed$window) {
    ...
  }]);
</pre>

Keep in mind that all of the annotation styles are equivalent and can be used anywhere in Angular
where injection is supported.

## Where can I use DI?

DI is pervasive throughout Angular. It is typically used in controllers and factory methods. 

### DI in controllers

Controllers are classes which are responsible for application behavior. The recommended way of 
declaring controllers is using the array notation:

<pre>
  someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) {
    ...
    $scope.aMethod = function() {
      ...
    }
    ...
  }]);
</pre>

This avoids the creation of global functions for controllers and also protects against minification.


### Factory methods

Factory methods are responsible for creating most objects in Angular. Examples are directives,
services, and filters. The factory methods are registered with the module, and the recommended way
of declaring factories is:

<pre>
  angular.module('myModule', []).
    config(['depProvider', function(depProvider){
      ...
    }]).
    factory('serviceId', ['depService', function(depService) {
      ...
    }]).
    directive('directiveName', ['depService', function(depService) {
      ...
    }]).
    filter('filterName', ['depService', function(depService) {
      ...
    }]).
    run(['depService', function(depService) {
      ...
    }]);
</pre>
